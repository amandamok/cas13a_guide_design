---
title: "NCR Primary Guide Screening"
author: "Amanda Mok"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r setup, echo=F, include=F}
library(here)
library(reshape)
library(ggplot2)
library(patchwork)
library(nlme)
library(Biostrings)
library(bedr)
library(factoextra)
library(ggseqlogo)
library(glmnet)
library(randomForest)
library(emmeans)
library(prodlim)

knitr::opts_chunk$set(echo=F, cache=T, fig.width=8)

ref_dir <- file.path(here(), "ref_data")
project_dir <- file.path(here(), "NCR")
traces_dir <- file.path(project_dir, "traces")
if(!dir.exists(traces_dir)) { dir.create(traces_dir) }
structure_dir <- file.path(project_dir, "structures")
mixed <- T

ucb_colors <- as.list(read.csv(file.path(project_dir, "palette.csv"), header=F)[,2])
names(ucb_colors) <- read.csv(file.path(project_dir, "palette.csv"), header=F)[,1]
```

```{r define_functions}
compute_rate <- function(data_subset, 
                         x="time",
                         y="signal_bkgdSubtract") {
  # screening_data: data.frame
  # x: character; column name to regress against
  # y: character; column name to regress
  model_formula <- formula(paste(y, "~", x))
  model_fit <- lm(model_formula, data_subset)
  model_rate <- coef(model_fit)[x]
  return(model_rate)
}

analyze_guide <- function(screening_data, guide,
                          signal="signal_bkgdSubtract",
                          time_start=15, mixed_model=F) {
  # screening_data: data.frame
  # guide: character
  # signal: character; column in screening_data to be used for linear regression
  # model: formula to be used for lm() regression
  # time_start: timepoint to start regression
  # mixed_model: logical; whether to run linear regression with random effects for 384-well
  data_subset <- subset(screening_data, guide_id==guide)
  data_subset$activator <- relevel(data_subset$activator, ref="noActivator")
  time_stop <- signif(max(data_subset$time))
  if(!mixed_model) {
    # compute fit
    model_fit <- lm(formula(paste(signal, "~ time*activator")), 
                    data=subset(data_subset, time >= time_start))
    # predict trajectory
    model_fit_coef <- coef(model_fit)
    data_predict <- expand.grid(time=seq(time_start, time_stop, 1),
                                activator=c("noActivator", "100fM"))
    data_predict[[signal]] <- predict(model_fit, newdata=data_predict)
    # pull coefficients
    guide_coef <- data.frame(summary(model_fit)$coefficients, guide_id=guide,
                             coef=rownames(summary(model_fit)$coefficients), row.names=NULL)
    colnames(guide_coef)[colnames(guide_coef)=="Pr...t.."] <- "p.value"
    colnames(guide_coef)[colnames(guide_coef)=="Std..Error"] <- "Std.Error"
  } else {
    # compute fit
    model_fit <- nlme::lme(formula(paste(signal, "~ time*activator")),
                           random = ~ 1 + time | well_384, 
                           data = subset(data_subset, time >= time_start))
    # predict trajectory
    model_fit_coef <- summary(model_fit)$tTable[,1]
    data_predict_noActivator <- data.frame(time=seq(time_start, time_stop, 1),
                                           activator="noActivator")
    data_predict_noActivator[[signal]] <- model_fit_coef["(Intercept)"] + 
      data_predict_noActivator$time * model_fit_coef["time"]
    data_predict_100fM <- data.frame(time=seq(time_start, time_stop, 1),
                                     activator="100fM")
    data_predict_100fM[[signal]] <- model_fit_coef["(Intercept)"] + 
      model_fit_coef["activator100fM"] +
      data_predict_100fM$time * (model_fit_coef["time"] + model_fit_coef["time:activator100fM"])
    data_predict <- rbind(data_predict_noActivator, data_predict_100fM)
    # pull fixed effects
    guide_coef <- data.frame(summary(model_fit)$tTable, guide_id=guide,
                             coef=rownames(summary(model_fit)$varFix), row.names=NULL)
    colnames(guide_coef)[colnames(guide_coef)=="Value"] <- "Estimate"
    guide_coef <- guide_coef[, -which(colnames(guide_coef)=="DF")]
  }
  # make plot
  plot_max <- max(data_subset[[signal]], na.rm=T)
  plot_width <- max(data_subset[[signal]], na.rm=T) - min(data_subset[[signal]], na.rm=T)
  rate_noActivator <- model_fit_coef["time"]
  rate_100fM <- model_fit_coef["time"] + model_fit_coef["time:activator100fM"]
  plot_text <- data.frame(x=10,
                          y=plot_max - c(1:3)*plot_width/20,
                          text=c(paste("RNP-only rate:", signif(rate_noActivator, 3)),
                                 paste("100 fM rate:", signif(rate_100fM, 3)),
                                 paste("p =", 
                                       signif(subset(guide_coef, coef=="time:activator100fM")$p.value, 3))))
  guide_plot <- ggplot(data_predict, 
                       aes_string(x="time", y=signal, col="activator")) +
    geom_line(size=3) + 
    geom_point(data=data_subset, 
               aes_string(x="time", y=signal, col="activator"), alpha=0.5) +
    geom_text(data=plot_text, aes(x=x, y=y, label=text), col="black", hjust=0) +
    theme_bw() + # scale_color_manual(values=c("red", "black")) +
    scale_color_manual(values=c(ucb_colors$`California Gold`, ucb_colors$`Berkeley Blue`)) +
    ggtitle(paste0("NCR_", guide)) + xlab("time (min)") + ylab("signal (RFU)")
  return(list(plot=guide_plot, coef=guide_coef))
}

compute_detection_time <- function(screening_data, guide, 
                                   signal="signal_bkgdSubtract") {
  # screening_data: data.frame
  # guide: character
  # signal: character; column in screening_data to be used for linear regression
  data_subset <- subset(screening_data, guide_id==guide)
  data_subset$activator <- relevel(data_subset$activator, ref="noActivator")
  timepoints <- sort(unique(data_subset$time))
  timepoint_ttest <- lapply(timepoints,
                            function(x) {
                              t.test(formula(paste(signal, "~ activator")), 
                                     data=data_subset,
                                     subset=(data_subset$time==x))
                            })
  timepoint_pvalue <- sapply(seq_along(timepoint_ttest),
                             function(num_tests) {
                               tmp_pvalues <- sapply(timepoint_ttest[1:num_tests],
                                                     function(x) x$p.value)
                               tmp_pvalues <- p.adjust(tmp_pvalues, method="fdr")
                               return(tmp_pvalues[length(tmp_pvalues)])
                             })
  if(!any(timepoint_pvalue < 0.05)) {
    return(NA)
  } else {
    return(data_subset$time[which.max(timepoint_pvalue < 0.05)])
  }
}

load_sam <- function(sam_fname) {
  # sam_fname: character; file.path to sam alignment file
  sam_colnames <- c("qname", "flag", "rname", "pos", "mapq",
                  "cigar", "rnext", "pnext", "tlen", "seq", "qual")
  sam_data <- read.table(sam_fname, comment.char="@")
  colnames(sam_data)[seq(length(sam_colnames))] <- sam_colnames
  return(sam_data)
}

plot_guide_feature_cor <- function(plot_data, x, x_lab, y, y_lab, in_vivo=F) {
  # plot_data: data.frame; data to be plotted with ggplot
  # x: character; name of column in plot_data for x-axis
  # x_lab: character; label for x-axis
  # y: character; name of column in plot_data for y-axis
  # y_lab: character; label for y-axis
  # in_vivo: logical; whether both annotations were generated in an in vivo setting
  feature_cor <- round(as.numeric(cor(plot_data[x], plot_data[y], 
                                      method="spearman")), 
                       digits=2)
  cor_plot <- ggplot(plot_data, aes_string(x=x, y=y)) + 
    geom_point(col=ifelse(in_vivo, "black", "darkgrey")) +
    geom_smooth(method=lm, formula=y~x) + theme_bw() + 
    xlab(x_lab) + ylab(y_lab) +
    geom_label(data=data.frame(x=-Inf, y=Inf, label=paste("cor =", feature_cor)),
               aes(x=x, y=y, label=label),
               hjust=0, vjust=1, col="red")
  return(cor_plot)
}

ggplot_violin <- function(plot_data, x_var, y_var="Estimate", fill_var=NULL,
                          x_lab="", y_lab="activator-dependent rate (RFU/min)",
                          binwidth=1) {
  # plot_data: data.frame ; input to ggplot()
  # x_var: character; x argument for aes_string()
  # y_var: character; y argument for aes_string()
  # fill_var: character; fill argument for aes_string
  # xlab: character; argument for xlab()
  # ylab: character; argument for ylab()
  # binwidth: numeric; argument for geom_dotplot
  if(is.null(fill_var)) {
    fill_var <- x_var
  }
  ggplot(plot_data, aes_string(x=x_var, y=y_var)) + 
    geom_violin(aes_string(fill=fill_var), 
                draw_quantiles=c(0.25, 0.75), linetype="dashed") +
    geom_violin(fill="transparent", draw_quantiles=0.5) +
    geom_dotplot(binaxis="y", stackdir="center", binwidth=binwidth) + 
    theme_bw() + xlab(x_lab) + ylab(y_lab)
}

compute_nt_freq <- function(sequences, bases=c("A", "U", "C", "G")) {
  # sequences: character vector; sequences of same length
  # bases: character vector; letters to compute frequences of at each position
  seq_length <- unique(nchar(sequences))
  seq_nt <- matrix(unlist(strsplit(sequences, split="")), ncol=seq_length, byrow=T)
  seq_freq <- sapply(seq(seq_length),
                     function(x) {
                       sapply(bases,
                              function(base) {
                                mean(seq_nt[,x]==base)
                              })
                     })
  rownames(seq_freq) <- bases
  return(data.frame(t(seq_freq)))
}

calculate_relative_info <- function(q_ik, p_ik) {
  # q_ik: data.frame; base frequencies per position in queries (bases as columns)
  # p_ik: data.frame; base frequencies per position in background (bases as columns)
  num_positions <- nrow(q_ik)
  if(nrow(p_ik) != num_positions) {
    stop("q_ik and p_ik have differing number of positions")
  }
  if(any(!(colnames(q_ik) %in% colnames(p_ik)))) {
    stop("q_ik and p_ik have differing alphabets")
  }
  info_content <- sapply(seq(num_positions),
                         function(x) {
                           sum(q_ik[x,] * log2(q_ik[x,] / p_ik[x,]))
                         })
  denominator <- sapply(seq(num_positions),
                        function(x) {
                          sum(q_ik[x,] / p_ik[x,])
                        })
  base_heights <- sapply(colnames(q_ik),
                         function(base) {
                           q_ik[[base]]/p_ik[[base]]/denominator*info_content
                         })
  return(t(base_heights))
}

calculate_info <- function(q_ik, p_k=NULL) {
  # q_ik: data.frame; base frequencies per position in queries (bases as columns)
  # p_k: named numeric vector; background base frequencies
  num_positions <- nrow(q_ik)
  if(is.null(p_k)) {
    p_k <- rep(1, ncol(q_ik)) / ncol(q_ik)
    names(p_k) <- colnames(q_ik)
  } else {
    p_k <- p_k[match(colnames(q_ik), names(p_k))]
  }
  info_content <- sapply(seq(num_positions),
                         function(x) {
                           sum(q_ik[x,] * log2(q_ik[x,] / p_k))
                         })
  denominator <- sapply(seq(num_positions),
                        function(x) {
                          sum(q_ik[x,] / p_k)
                        })
  base_heights <- sapply(colnames(q_ik),
                         function(base) {
                           q_ik[[base]]/p_k[base]/denominator*info_content
                         })
  return(t(base_heights))
}

calculate_shannon_entropy <- function(q_ik) {
  # q_ik: data.frame; base frequencies per position in queries (bases as columns)
  position_info <- 2-rowSums(-q_ik*log2(q_ik))
  return(t(q_ik * position_info))
}

optimize_glmnet_hyperparameters <- function(input_data, fold_ids, 
                                            metric, family="gaussian") {
  # input_data: matrix; first column is response variable
  # family: character; "family" argument for glmnet()
  # metric: character; one of "r2" or "mse"
  # fold_ids: numeric vector; "foldid" argument for cv.glmnet()
  num_folds <- length(unique(fold_ids))
  # 1. fit all models
  alphas <- seq(0, 1, by=0.1)
  all_models <- lapply(alphas,
                       function(alpha) {
                         glmnet::cv.glmnet(input_data[, -1], input_data[, 1], 
                                           foldid=fold_ids, alpha=alpha)
                       })
  names(all_models) <- alphas
  # 2. calculate r^2 and perason correlation per split across all models
  all_models_stats <- lapply(seq_along(all_models),
                          function(alpha_id) {
                            lambdas <- all_models[[alpha_id]]$lambda
                            do.call(rbind,
                                    lapply(seq(num_folds),
                                           function(fold_id) {
                                             tmp_training <- subset(input_data,
                                                                    fold_ids != fold_id)
                                             tmp_testing <- subset(input_data,
                                                                   fold_ids == fold_id)
                                             tmp_fit <- glmnet::glmnet(tmp_training[, -1],
                                                                       tmp_training[, 1],
                                                                       alpha=alphas[alpha_id],
                                                                       lambda=lambdas)
                                             tmp_training_predict <- lapply(lambdas,
                                                                            function(lambda) {
                                                                              predict(tmp_fit,
                                                                                      newx=tmp_training[,-1],
                                                                                      s=lambda)
                                                                            })
                                             tmp_testing_predict <- lapply(lambdas,
                                                                           function(lambda) {
                                                                             predict(tmp_fit,
                                                                                     newx=tmp_testing[,-1],
                                                                                     s=lambda)
                                                                           })
                                             tmp_testing_null_deviance <- sum((tmp_testing[,1] -
                                                                                 mean(tmp_testing[,1]))^2)
                                             tmp_testing_r2 <- sapply(tmp_testing_predict,
                                                                      function(x) {
                                                                        1 - sum((tmp_testing[,1]-x)^2) / 
                                                                          tmp_testing_null_deviance
                                                                      })
                                             tmp_training_cor <- sapply(tmp_training_predict,
                                                                        function(x) {
                                                                          cor(x, tmp_training[,1])
                                                                        })
                                             tmp_testing_cor <- sapply(tmp_testing_predict,
                                                                       function(x) {
                                                                         cor(x, tmp_testing[,1])
                                                                       })
                                             return(data.frame(alpha=alphas[alpha_id],
                                                               fold_id=fold_id,
                                                               lambda=rep(lambdas, times=2),
                                                               r2=c(tmp_fit$dev.ratio, 
                                                                    tmp_testing_r2),
                                                               pearson_r=c(tmp_training_cor,
                                                                           tmp_testing_cor),
                                                               split=rep(c("training", "testing"),
                                                                         each=length(lambdas))))
                                           }))
                          })
  all_models_stats <- do.call(rbind, all_models_stats)
  all_models_stats$alpha <- factor(as.character(all_models_stats$alpha),
                                   levels=as.character(alphas))
  all_models_stats$split <- factor(all_models_stats$split,
                                   levels=c("training", "testing"))
  all_models_r2 <- aggregate(r2 ~ alpha + lambda + split, 
                             data=all_models_stats, FUN=mean)
  r2_plot <- ggplot(all_models_r2, aes(x=lambda, y=r2, col=alpha)) + 
    geom_line() + theme_bw() + scale_x_log10() + 
    facet_grid(split ~ ., scales="free_y") + 
    xlab(expr(lambda)) + ylab(bquote("mean"~r^2)) + labs(col=expr(alpha)) + 
    ggtitle(paste0("Elastic net regression, ", num_folds, "-fold cross-validation"))
  all_models_pearson_r <- aggregate(pearson_r ~ alpha + lambda + split, 
                                    data=all_models_stats, FUN=mean)
  pearson_r_plot <- ggplot(all_models_pearson_r, aes(x=lambda, y=pearson_r, col=alpha)) + 
    geom_line() + theme_bw() + scale_x_log10() + 
    facet_grid(split ~ ., scales="free_y") + 
    xlab(expr(lambda)) + ylab(bquote("pearson"~r)) + labs(col=expr(alpha)) + 
    ggtitle(paste0("Elastic net regression, ", num_folds, "-fold cross-validation"))
  # 3. calculate mean squared error across all models
  all_models_MSE <- lapply(seq_along(all_models),
                           function(x) {
                             tmp_fit <- all_models[[x]]
                             data.frame(lambda=tmp_fit$lambda,
                                        cv_error=tmp_fit$cvm,
                                        cv_upper=tmp_fit$cvup,
                                        cv_lower=tmp_fit$cvlo,
                                        num_nonzero=tmp_fit$nzero,
                                        alpha=alphas[x],
                                        dev_ratio=tmp_fit$glmnet.fit$dev.ratio)
                           })
  all_models_MSE <- do.call(rbind, all_models_MSE)
  all_models_MSE$alpha <- factor(all_models_MSE$alpha, 
                                 levels=as.character(alphas))
  mse_plot <- ggplot(all_models_MSE, aes(x=lambda, y=cv_error, col=alpha)) + 
    geom_line() + theme_bw() + scale_x_log10() + scale_y_log10() + 
    xlab(expr(lambda)) + labs(col=bquote(alpha)) + 
    ylab(paste0("cross-validated error (k=", num_folds, ")"))
  # 4. calculate best r^2 and pearson correlation per split per alpha
  # best r^2
  all_models_best_r2 <- do.call(rbind,
                                lapply(alphas,
                                       function(a) {
                                         tmp_testing <- subset(all_models_r2, 
                                                               split=="testing" & alpha==a)
                                         tmp_lambda <- tmp_testing$lambda[which.max(tmp_testing$r2)]
                                         subset(all_models_r2, alpha==a & lambda==tmp_lambda)
                                       }))
  best_r2_plot <- ggplot(all_models_best_r2, 
                         aes(x=as.numeric(as.character(alpha)), 
                             y=r2, col=split)) + 
    geom_point() + geom_line(alpha=0.5) + theme_bw() +
    xlab(expr(alpha)) + ylab(bquote("mean"~r^2)) + 
    scale_color_manual(values=c("#E69F00", "#56B4E9"))
  # best pearson r
  all_models_best_pearson_r <- do.call(rbind,
                                       lapply(alphas,
                                              function(a) {
                                                tmp_testing <- subset(all_models_pearson_r, 
                                                                      split=="testing" & alpha==a)
                                                tmp_lambda <- tmp_testing$lambda[which.max(tmp_testing$pearson_r)]
                                                subset(all_models_pearson_r, alpha==a & lambda==tmp_lambda)
                                              }))
  best_pearson_r_plot <- ggplot(all_models_best_pearson_r, 
                                aes(x=as.numeric(as.character(alpha)),
                                    y=pearson_r, col=split)) + 
    geom_point() + geom_line(alpha=0.5) + theme_bw() + 
    xlab(expr(alpha)) + ylab(bquote("mean pearson"~r)) + 
    scale_color_manual(values=c("#E69F00", "#56B4E9"))
  # pearson r, optimizing r^2
  match_var <- c("alpha", "lambda", "split")
  all_models_best_r2_pearson_r <- all_models_pearson_r[prodlim::row.match(all_models_best_r2[, match_var],
                                                                          all_models_pearson_r[, match_var]),]
  best_r2_pearson_r_plot <- ggplot(all_models_best_r2_pearson_r, 
                                   aes(x=as.numeric(as.character(alpha)),
                                       y=pearson_r, col=split)) + 
    geom_point() + geom_line(alpha=0.5) + theme_bw() + 
    xlab(expr(alpha)) + ylab(bquote("mean pearson"~r)) + 
    scale_color_manual(values=c("#E69F00", "#56B4E9"))
  # r^2, optimizing pearson r
  all_models_best_pearson_r_r2 <- all_models_r2[prodlim::row.match(all_models_best_pearson_r[, match_var],
                                                                   all_models_r2[, match_var]),]
  best_pearson_r_r2_plot <- ggplot(all_models_best_pearson_r_r2, aes(x=as.numeric(as.character(alpha)),
                                                                     y=r2, col=split)) + 
    geom_point() + geom_line(alpha=0.5) + theme_bw() + 
    xlab(expr(alpha)) + ylab(bquote("mean"~r^2)) + 
    scale_color_manual(values=c("#E69F00", "#56B4E9"))
  # 5. choose optimal hyperparameters
  if(metric=="mse") {
    best_param <- do.call(rbind, 
                          lapply(alphas,
                                 function(a) {
                                   tmp_fit <- subset(all_models_MSE, alpha==a)
                                   tmp_fit[which.min(tmp_fit$cv_error),]
                                 }))
    best_param <- best_param[which.min(best_param$cv_error),]
  } else {
    min_r2 <- with(subset(all_models_best_r2, split=="testing"), max(r2) - sd(r2))
    best_param <- subset(all_models_best_r2, split=="testing" & r2 >= min_r2)$alpha
    best_param <- subset(all_models_best_r2, split=="training" & alpha %in% best_param)
    best_param <- best_param[which.max(best_param$r2), ]
  }
  best_lambda <- best_param$lambda
  best_alpha <- as.numeric(as.character(best_param$alpha))
  best_r2_plot <- best_r2_plot + 
    geom_point(data=subset(all_models_best_r2, alpha==best_alpha & lambda==best_lambda),
               aes(x=as.numeric(as.character(alpha)), y=r2), col="red") + 
    ggtitle("optimal hyperparameters:", 
            subtitle=bquote(alpha~"="~.(best_alpha)~";"~lambda~"="~.(best_lambda)))
  best_pearson_r_plot <- best_pearson_r_plot + 
    geom_point(data=subset(all_models_best_pearson_r, alpha==best_alpha & lambda==best_lambda),
               aes(x=as.numeric(as.character(alpha)), y=pearson_r), col="red")
  r2_plot <- r2_plot + 
    geom_point(data=subset(all_models_best_r2, alpha==best_alpha & lambda==best_lambda),
               aes(x=lambda, y=r2), col="red")
  mse_plot <- mse_plot + 
    geom_point(data=subset(all_models_MSE, alpha==best_alpha & lambda==best_lambda),
               aes(x=lambda, y=cv_error), col="red")
  
  return(list(all_models=all_models, all_models_stats=all_models_stats, MSE=all_models_MSE,
              best_alpha=best_alpha, best_lambda=best_lambda, metric=metric,
              r2_plot=r2_plot, pearson_r_plot=pearson_r_plot, mse_plot=mse_plot, 
              best_r2_plot=best_r2_plot, best_pearson_r_plot=best_pearson_r_plot,
              best_r2_pearson_r_plot=best_r2_pearson_r_plot,
              best_pearson_r_r2_plot=best_pearson_r_r2_plot))
}

plot_coefs <- function(fit_obj, best_alpha, best_lambda) {
  # fit_obj: cv.glmnet object
  # best_alpha: numeric
  # best_lambda: numeric
  coefs <- coef(fit_obj, s=best_lambda)[, 1]
  coefs <- data.frame(matrix(unlist(strsplit(names(coefs)[-1],
                                             split="_")),
                             ncol=3, byrow=T),
                      coefs[-1],
                      row.names=NULL)
  colnames(coefs) <- c("type", "position", "coef", "value")
  coefs$position <- as.numeric(sub("\\.", "-", coefs$position))
  coef_plot <- ggplot(coefs, aes(x=position, y=value, fill=coef)) + 
    geom_col(position="stack") + geom_hline(yintercept=0) + 
    xlab("position relative to spacer") + ylab("regression coefficient") + 
    theme_classic() + labs(fill="") + theme(legend.position="bottom") + 
    scale_fill_manual(values=c(RColorBrewer::brewer.pal(4, "Set1"), "grey")) +
    annotate("rect", xmin=0.5, xmax=19.5, 
             ymin=max(coefs$value)+1, ymax=max(coefs$value+2), fill="black") + 
    annotate("text", x=10, y=max(coefs$value)+1.5, 
             label="protospacer", col="white") +
    annotate("rect", xmin=-3.5, xmax=0.5, 
             ymin=max(coefs$value)+1, ymax=max(coefs$value+2), fill="darkgrey") + 
    annotate("text", x=-1.5, y=max(coefs$value)+1.5, 
             label="anti-tag", col="white")
  if(max(coefs$position) >= 50) {
    coef_plot <- coef_plot + 
      annotate("rect", xmin=30.5, xmax=49.5, 
               ymin=max(coefs$value)+1, ymax=max(coefs$value)+2, 
               fill="darkgrey") + 
      annotate("text", x=40.5, y=max(coefs$value)+1.5, 
               label="cis-cleavage neighborhood", col="white")
  }
  return(coef_plot)
}

plot_fold_fits <- function(input_data, fold_ids, best_alpha, best_lambda) {
  # input_data: matrix; first column is response variable
  # fold_ids: numeric vector; folds assigned to each row of input_data
  # best_alpha: numeric
  # best_lambda: numeric
  num_folds <- length(unique(fold_ids))
  fold_plots <- lapply(seq(num_folds),
                       function(x) {
                         # split data into training and testing
                         tmp_data <- split(seq(nrow(input_data)), fold_ids==x)
                         tmp_data <- lapply(tmp_data,
                                            function(indices) {
                                              data.frame(input_data[indices,])
                                            })
                         names(tmp_data) <- c("training", "testing")
                         # compute fit
                         tmp_fit <- glmnet(as.matrix(tmp_data$training)[, -1],
                                           tmp_data$training[, 1],
                                           alpha=best_alpha, lambda=best_lambda)
                         # predict outcome
                         tmp_data$training$predicted <- predict(tmp_fit,
                                                                newx=as.matrix(tmp_data$training)[, -1],
                                                                s=best_lambda)
                         tmp_data$testing$predicted <- predict(tmp_fit,
                                                               newx=as.matrix(tmp_data$testing)[, -1],
                                                               s=best_lambda)
                         # generate plot
                         tmp_plot_data <- rbind(data.frame(tmp_data$training, split="training"),
                                                data.frame(tmp_data$testing, split="testing"))
                         tmp_r2 <- sapply(tmp_data,
                                          function(x) {
                                            with(x, 1-sum((rate-predicted)^2)/sum((rate-mean(rate))^2))
                                          })
                         tmp_cor <- sapply(tmp_data,
                                           function(x) {
                                             with(x, cor(rate, predicted))
                                           })
                         tmp_plot <- ggplot(tmp_plot_data, aes(x=rate, y=predicted, col=split)) + 
                           geom_point() + geom_abline(slope=1, intercept=0) + theme_bw() + 
                           ggtitle(paste("fold:", x), subtitle=paste("# non-zero:", tmp_fit$df)) + 
                           xlab("true rate (RFU/min)") + ylab("predicted rate (RFU/min)") + 
                           scale_color_manual(values=c(ucb_colors$`California Gold`, ucb_colors$Lawrence)) + 
                           annotate(geom="text", x=Inf, y=-Inf, col=ucb_colors$Lawrence,
                                    label=bquote(r^2~"="~.(round(tmp_r2["training"], digits=3))),
                                    hjust="inward", vjust=-2) + 
                           annotate(geom="text", x=Inf, y=-Inf, col=ucb_colors$`California Gold`,
                                    label=bquote(r^2~"="~.(round(tmp_r2["testing"], digits=3))),
                                    hjust="inward", vjust=-1) + 
                           annotate(geom="text", x=Inf, y=Inf, col="black", label="y=x",
                                    hjust="inward", vjust="inward") + 
                           annotate(geom="text", x=-Inf, y=Inf, col=ucb_colors$Lawrence,
                                    label=bquote(rho~"="~.(round(tmp_cor["training"], digits=2))),
                                    hjust="inward", vjust=1.5) +
                           annotate(geom="text", x=-Inf, y=Inf, col=ucb_colors$`California Gold`,
                                    label=bquote(rho~"="~.(round(tmp_cor["testing"], digits=2))),
                                    hjust="inward", vjust=2.5)
                         return(tmp_plot)
                       })
  fold_plots <- lapply(seq_along(fold_plots),
                       function(x) {
                         if(x != length(fold_plots)) {
                           return(fold_plots[[x]] + guides(col="none"))
                         } else {
                           return(fold_plots[[x]])
                         }
                       })
  return(wrap_plots(fold_plots, nrow=1))
}

label_p <- function(pvalues, thresholds=c(0.05, 0.01, 0.001)) {
  # pvalues: numeric vector of p-values
  # thresholds: numeric vector with length = 3
    ## >= 1st value: ns
    ## between 1st and 2nd value: *
    ## between 2nd and 3rd value: **
    ## lower than 3rd value: ***
  as.character(cut(pvalues, breaks=c(0, sort(thresholds), 1), 
                   labels=c("***", "**", "*", "ns")))
}
```

# Data
* 204 guides (192 20mers, 12 28mers) screened in triplicate at 0 and 100 fM activator
    + **96 "good" guides (NCR_504-599)**: selected for good secondary structure (maintains crRNA hairpin, no folding in spacer) and high sensitivity to SARS-CoV-2 genomic diversity; varies by whether target is structured (predicted by SHAPE-MaP and DMA-MaPseq) and whether guide targets any organism in NCBI viral and bacterial database
    + **15 Ott lab guides (NCR_600-614)**
    + **48 control "bad" guides (NCR_1305-1352)**: selected for bad secondary structure (crRNA folding interferes with hairpin structure and/or significant folding in spacer)
    + **48 random guides tiling SARS-CoV-2 (NCR_1353-1400)**: good secondary structure, high sensitivity
    + **12 28mer guides (NCR_1407-1418)**: span range of predicted activity by ADAPT (also 28mer)
* plate controls: 612_Control and No_Protein
* repeat sequence: uagaccaccccaaaaaugaaggggacuaaaac

Example structure of a "good" guide

```{r good_guide}
knitr::include_graphics(path.expand(file.path(structure_dir, "good_guide.png")))
```

```{r load_guide_features}
order1 <- read.delim(file.path(project_dir, "primary_guide_design_20200710.tsv"))
order2 <- read.delim(file.path(project_dir, "primary_control_guides_20210129.tsv"))
order2$spacer <- substr(order2$sequence, 33, 52)
adapt_28mer <- read.delim(file.path(project_dir, "adapt_28mers.tsv"))
guide_28mer <- read.delim(file.path(project_dir, "cas13a_28nt_results_summary.txt"))
guide_28mer <- guide_28mer[match(adapt_28mer$target.sequences, guide_28mer$target),]
guide_28mer$NCR.id <- adapt_28mer$New.Name
guide_features <- intersect(intersect(colnames(order1), colnames(order2)),  colnames(guide_28mer))
guide_features <- rbind(order1[, guide_features], order2[, guide_features], guide_28mer[, guide_features])
guide_features$spacer_structure <- guide_features$crRNA_spacer_basepairs / nchar(guide_features$spacer)
guide_features$crRNA_spacer_basepairs <- factor(guide_features$crRNA_spacer_basepairs, 
                                                levels=sort(unique(guide_features$crRNA_spacer_basepairs)))
guide_features$group <- sapply(seq(nrow(guide_features)),
                               function(x) {
                                 if(guide_features$has_crRNA_hairpin[x] & 
                                    guide_features$crRNA_spacer_basepairs[x] == 0) {
                                   return("good guide")
                                 } else {
                                   paste0(ifelse(guide_features$has_crRNA_hairpin[x], 
                                                 "hasHairpin", "noHairpin"), "/",
                                          guide_features$crRNA_spacer_basepairs[x], "bp")
                                 }
                               })
guide_features$group <- factor(guide_features$group,
                               levels=c("good guide", 
                                        "hasHairpin/4bp", "noHairpin/4bp",
                                        "hasHairpin/6bp",
                                        "noHairpin/7bp",
                                        "noHairpin/8bp",
                                        "noHairpin/9bp",
                                        "hasHairpin/10bp", "noHairpin/10bp",
                                        "noHairpin/11bp",
                                        "hasHairpin/12bp",
                                        "noHairpin/13bp",
                                        "noHairpin/14bp",
                                        "noHairpin/15bp",
                                        "hasHairpin/16bp", "noHairpin/16bp",
                                        "noHairpin/17bp"))
guide_features$class <- sapply(as.numeric(sub("NCR_", "", guide_features$NCR.id)),
                               function(x) {
                                 if(x >= 504 & x <= 599) {
                                   return("good")
                                 } else {
                                   if(x >= 600 & x <= 614) {
                                     return("Ott")
                                   } else {
                                     if(x >= 1305 & x <= 1352) {
                                       return("bad")
                                     } else {
                                       if(x >= 1353 & x <= 1400) {
                                         return("random")
                                       } else {
                                         if(x >= 1407 & x <= 1418) {
                                           return("28mer")
                                         } else {
                                           return(NA)
                                         }
                                       }
                                     }
                                   }
                                 }
                               })
guide_features$class <- factor(guide_features$class, levels=c("good", "Ott", "bad", "random", "28mer"))
```

```{r guide_features_gRNA_MFE}
all_guides <- read.table(file.path(here(), "outputs", "covid", "cas13a_20nt",
                         "cas13a_results_summary.txt"), header=T)
guide_features$gRNA_MFE <- all_guides$gRNA_MFE[match(guide_features$start,
                                                     all_guides$start)]
```

```{r guide_features_crRNA_structure}
repeat_sequence <- "uagaccaccccaaaaaugaaggggacuaaaac"
RNAfold_20nt <- read.table(file.path(here(), "outputs", "covid", "cas13a_20nt", 
                                     "score_RNAfold_crRNAs.txt"), header=T)
RNAfold_28nt <- read.table(file.path(here(), "outputs", "covid", "cas13a_28nt",
                                     "score_RNAfold_crRNAs.txt"), header=T)
guide_features$structure <- sapply(seq(nrow(guide_features)),
                                   function(x) {
                                     tmp_start <- guide_features$start[x]
                                     tmp_spacer_length <- nchar(guide_features$spacer[x])
                                     tmp_structure <- subset(get(paste0("RNAfold_", 
                                                                        tmp_spacer_length, 
                                                                        "nt")),
                                                             start == tmp_start)
                                     return(tmp_structure$structure[1])
                                   })
guide_features$direct_repeat <- factor(substr(guide_features$structure, 
                                              1, nchar(repeat_sequence)))
guide_features$direct_repeat <- relevel(guide_features$direct_repeat,
                                        ref=".......((((.........))))........")
```

```{r hybridization_MFE}
guide_features$target <- as.character(reverseComplement(RNAStringSet(guide_features$spacer)))
guide_features$hybridization_MFE <- sapply(seq(nrow(guide_features)),
                                           function(x) {
                                             tmp <- system(paste0('printf "', 
                                                                  guide_features$spacer[x],
                                                                  '\n',
                                                                  guide_features$target[x],
                                                                  '" | RNAduplex'),
                                                           intern=T)
                                             tmp <- strsplit(tmp, split=" ")[[1]][[11]]
                                           })
guide_features$hybridization_MFE <- as.numeric(sub("\\(", "",
                                                   sub("\\)", "", 
                                                       guide_features$hybridization_MFE)))
```

## Viral secondary structure

* Manfredonia et al. *NAR* (2020)
    + SHAPE-MaP/DMS-MaPseq of *in vitro* refolded viral genome in ~500bp tiles
    + data: sequences of single-stranded (low Shannon entropy, high SHAPE) regions (3599 nt; 12.0% of genome)
    + per-guide metric: % of target labeled as single-stranded
* Lan et al. *bioRxiv* (2020)
    + DMS-MaPseq in infected Vero E6 cells
    + data: coordinates of unstructured/structured regions (6010 nt; 20.1% of genome)
    + per-guide metric: % of target labeled as unstructured
* Sun et al. *Cell* (2021)
    + icSHAPE in infected Huh7.5.1 cells & on extracted RNA
    + data: icSHAPE score [0,1] per nucleotide
    + per-the guide metric: mean icSHAPE score (higher = more likely to be single-stranded)
* Huston et al. *Molecular Cell* (2021)
    + SHAPE-MaP of purified RNA from infected Vero E6 cells
    + data: RNAstructure connectivity table (CT) per nucleotide (12527 positions unbound; 41.9% of genome)
    + per-guide metric: % target labeled as unpaired

```{r load_viral_genome_structure, fig.height=4}
viral_genome <- Biostrings::readDNAStringSet(file.path(ref_dir, "NC_045512v2.fa"))
viral_genome <- data.frame(pos = seq(nchar(viral_genome)),
                           base = unlist(strsplit(as.character(viral_genome), 
                                                  split="")),
                           spacer_base = unlist(strsplit(as.character(complement(viral_genome)), 
                                                         split="")),
                           row.names=NULL)
viral_genome$base[viral_genome$base == "T"] <- "U"
viral_genome$spacer_base[viral_genome$spacer_base == "T"] <- "U"

# Manfredonia et al. NAR (2020)
manfredonia_prefix <- "manfredonia_2020_lowShannon_highSHAPE"
manfredonia_sam_fname <- file.path(ref_dir, paste0(manfredonia_prefix, ".sam"))
if(!file.exists(manfredonia_sam_fname)) {
  manfredonia <- openxlsx::read.xlsx(file.path(ref_dir, paste0(manfredonia_prefix, ".xlsx")),
                                   colNames=T, startRow=2)
  manfredonia_fasta <- Biostrings::DNAStringSet(manfredonia$Sequence)
  names(manfredonia_fasta) <- with(manfredonia, paste("region", From, To, sep="_"))
  manfredonia_fasta_fname <- file.path(ref_dir, paste0(manfredonia_prefix, ".fa"))
  Biostrings::writeXStringSet(manfredonia_fasta, filepath=manfredonia_fasta_fname)
  system(paste("bowtie --norc -v 2 -S -f", file.path(ref_dir, "wuhCor1"),
               manfredonia_fasta_fname, ">", manfredonia_sam_fname))
}
## add annotation
manfredonia_sam <- load_sam(manfredonia_sam_fname)
viral_genome$manfredonia <- "."
for(x in seq(nrow(manfredonia_sam))) {
  region_start <- manfredonia_sam$pos[x]
  region_end <- region_start + nchar(manfredonia_sam$seq[x]) - 1
  viral_genome$manfredonia[region_start:region_end] <- "lowShannon/highSHAPE"
}

# Lan et al. bioRxiv (2020)
lan_structured_prefix <- "lan_2020_structured"
lan_structured_sam_fname <- file.path(ref_dir, paste0(lan_structured_prefix, ".sam"))
if(!file.exists(lan_structured_sam_fname)) {
  lan_structured <- read.csv(file.path(ref_dir, paste0(lan_structured_prefix, ".csv")))
  lan_structured <- cbind("MN985325.1", lan_structured)
  lan_structured_bed_fname <- file.path(ref_dir, paste0(lan_structured_prefix, ".bed"))
  write.table(lan_structured, file=lan_structured_bed_fname,
              sep="\t", quote=F, row.names=F, col.names=F)
  lan_structured_fasta_fname <- file.path(ref_dir, paste0(lan_structured_prefix, ".fa"))
  system(paste("bedtools getfasta -fi",
               file.path(ref_dir, "MN985325v1.fa"),
               "-bed", lan_structured_bed_fname,
               "-fo", lan_structured_fasta_fname))
  system(paste("bowtie --norc -v 2 -S -f", file.path(ref_dir, "wuhCor1"),
               lan_structured_fasta_fname, ">", lan_structured_sam_fname))
}
lan_unstructured_prefix <- "lan_2020_unstructured"
lan_unstructured_sam_fname <- file.path(ref_dir, paste0(lan_unstructured_prefix, ".sam"))
if(!file.exists(lan_unstructured_sam_fname)) {
  lan_unstructured <- read.csv(file.path(ref_dir, paste0(lan_unstructured_prefix, ".csv")))
  lan_unstructured <- cbind("MN985325.1", lan_unstructured)
  lan_unstructured_bed_fname <- file.path(ref_dir, paste0(lan_unstructured_prefix, ".bed"))
  write.table(lan_unstructured, file=lan_unstructured_bed_fname,
              sep="\t", quote=F, row.names=F, col.names=F)
  lan_unstructured_fasta_fname <- file.path(ref_dir, paste0(lan_unstructured_prefix, ".fa"))
  system(paste("bedtools getfasta -fi",
               file.path(ref_dir, "MN985325v1.fa"),
               "-bed", lan_unstructured_bed_fname,
               "-fo", lan_unstructured_fasta_fname))
  system(paste("bowtie --norc -v 2 -S -f", file.path(ref_dir, "wuhCor1"),
               lan_unstructured_fasta_fname, ">", lan_unstructured_sam_fname))
}
# add annotations
lan_structured_sam <- load_sam(lan_structured_sam_fname)
lan_unstructured_sam <- load_sam(lan_unstructured_sam_fname)
viral_genome$lan <- "."
for(x in seq(nrow(lan_structured_sam))) {
  region_start <- lan_structured_sam$pos[x]
  region_end <- region_start + nchar(lan_structured_sam$seq[x]) - 1
  viral_genome$lan[region_start:region_end] <- "structured"
}
for(x in seq(nrow(lan_unstructured_sam))) {
  region_start <- lan_unstructured_sam$pos[x]
  region_end <- region_start + nchar(lan_unstructured_sam$seq[x]) - 1
  region <- viral_genome$lan[region_start:region_end]
  region <- paste0(region, "_unstructured")
  viral_genome$lan[region_start:region_end] <- region
}
viral_genome$lan[viral_genome$lan=="._unstructured"] <- "unstructured"
viral_genome$lan[viral_genome$lan=="structured_unstructured"] <- "both"

# Sun et al. Cell (2021)
sun_invivo <- openxlsx::read.xlsx(file.path(ref_dir, "sun_2021_icSHAPE.xlsx"),
                                  sheet="SARS2-invivo", na.strings="NULL")
viral_genome$sun_invivo <- sun_invivo$`icSHAPE-score`
sun_invitro <- openxlsx::read.xlsx(file.path(ref_dir, "sun_2021_icSHAPE.xlsx"),
                                   sheet="SARS2-invitro", na.strings="NULL")
viral_genome$sun_invitro <- sun_invitro$`icSHAPE-score`

# Huston et al. Molecular Cell*(2021)
huston <- read.table(file.path(ref_dir, "huston_2021_structure.ct"), skip=1,
                     col.names=c("index", "base", "previous_index", "next_index", 
                                 "paired_to", "natural_numbering"))
viral_genome$huston <- as.numeric(huston$paired_to)

# clustering of in vivo metrics
viral_genome_invivo <- data.frame(lan = (viral_genome$lan %in% c("both", "unstructured")),
                                  sun = (viral_genome$sun_invivo >= 0.5),
                                  huston = (viral_genome$huston == 0))
viral_genome$invivo <- ifelse(rowSums(viral_genome_invivo, na.rm=T) >= 2,
                              "unstructured", "structured")

(ggplot(viral_genome, aes(x=manfredonia)) + geom_bar() + theme_bw() + 
    ggtitle("Manfredonia") + xlab("") + ylab("# genomic positions") +
    theme(axis.text.x=element_text(angle=45, hjust=1))) +
  (ggplot(viral_genome, aes(x=lan)) + geom_bar() + theme_bw() +
     ggtitle("Lan") + xlab("") + ylab("# genomic positions") + 
     theme(axis.text.x=element_text(angle=45, hjust=1))) +
  (ggplot(viral_genome, aes(x=sun_invivo)) + geom_density(fill="grey") + theme_bw() +
     ggtitle("Sun (in vivo)") + xlab("") + ylab("") +
     theme(axis.text.x=element_text(angle=45, hjust=1))) +
  (ggplot(viral_genome, aes(x=sun_invitro)) + geom_density(fill="grey") + theme_bw() +
     ggtitle("Sun (in vitro)") + xlab("") + ylab("") +
     theme(axis.text.x=element_text(angle=45, hjust=1))) +
  (ggplot(viral_genome, aes(x=(huston==0))) + geom_bar() + theme_bw() +
     ggtitle("Huston") + xlab("") + ylab("# genomic positions")) + 
  plot_layout(nrow=1, widths=rep(1, 5))
```

```{r guide_downstream_features}
U_window <- 30
guide_features$downstream_U <- sapply(seq(nrow(guide_features)),
                                      function(x) { # downstream wrt spacer
                                        # region_start <- guide_features$start[x] +
                                        #   nchar(guide_features$spacer[x])
                                        # region_end <- region_start + U_window - 1
                                        region_end <- guide_features$start[x] - 1
                                        region_start <- region_end - U_window + 1
                                        tmp_region <- viral_genome[region_start:region_end,]
                                        mean(tmp_region$base == "U")
                                      })
guide_features$downstream_unstructured_U <- sapply(seq(nrow(guide_features)),
                                                   function(x) { # downstream wrt spacer
                                                     # region_start <- guide_features$start[x] +
                                                     #   nchar(guide_features$spacer[x])
                                                     # region_end <- region_start + U_window - 1
                                                     region_end <- guide_features$start[x] - 1
                                                     region_start <- region_end - U_window + 1
                                                     tmp_region <- viral_genome[region_start:region_end,]
                                                     mean((tmp_region$base == "U") &
                                                            (tmp_region$invivo == "unstructured"))
                                                   })
guide_features$U_context <- sapply(seq(nrow(guide_features)),
                                   function(x) { # upstream/downstream wrt spacer
                                     upstream_start <- guide_features$start[x] - 1
                                     upstream_end <- upstream_start - U_window + 1
                                     downstream_start <- guide_features$start[x] + 
                                       nchar(guide_features$spacer[x])
                                     downstream_end <- downstream_start + U_window - 1
                                     tmp_region <- rbind(viral_genome[upstream_start:upstream_end,],
                                                         viral_genome[downstream_start:downstream_end,])
                                     mean(tmp_region$base=="U")
                                   })
guide_features$U_context_unstructured <- sapply(seq(nrow(guide_features)),
                                                function(x) {
                                                  upstream_start <- guide_features$start[x] - 1
                                                  upstream_end <- upstream_start - U_window + 1
                                                  downstream_start <- guide_features$start[x] + 
                                                    nchar(guide_features$spacer[x])
                                                  downstream_end <- downstream_start + U_window - 1
                                                  tmp_region <- rbind(viral_genome[upstream_start:upstream_end,],
                                                                      viral_genome[downstream_start:downstream_end,])
                                                  mean((tmp_region$base=="U") &
                                                         (tmp_region$invivo=="unstructured"))
                                   })
guide_features$antitag <- sapply(seq(nrow(guide_features)),
                                      function(x) {
                                        tmp_position <- guide_features$start[x] + 
                                          nchar(guide_features$spacer[x])
                                        paste(viral_genome$base[tmp_position+(0:3)],
                                              collapse="")
                                      })
guide_features$antitag_pos1 <- substr(guide_features$antitag, 1, 1)
guide_features$antitag_label <- sapply(guide_features$antitag,
                                       function(x) {
                                         ifelse(grepl("^GUU", x), "GUU",
                                                ifelse(grepl("^GU", x), "GU",
                                                       ifelse(grepl("^G", x), "G",
                                                              substr(x, 1, 1))))
                                       })
guide_features$antitag_label <- factor(guide_features$antitag_label,
                                       levels=c("A", "C", "U", "G", "GU", "GUU"))
```

```{r guide_cis_cleavage_site}
cis_cleavage_start <- 20
cis_cleavage_window <- 20
guide_features$downstream_U <- sapply(seq(nrow(guide_features)),
                                      function(x) {
                                        region_start <- guide_features$start[x] +
                                          nchar(guide_features$spacer[x])
                                        region_end <- region_start + U_window - 1
                                        tmp_region <- viral_genome[region_start:region_end,]
                                        mean(tmp_region$base == "U")
                                      })
guide_features$cis_cleavage_site <- sapply(seq(nrow(guide_features)),
                                           function(x) {
                                             region_end <- guide_features$start[x] - 1 - 
                                               cis_cleavage_start + cis_cleavage_window/2
                                             region_start<- region_end - cis_cleavage_window + 1
                                             tmp_region <- viral_genome[region_start:region_end,]
                                             paste(tmp_region$base, collapse="")
                                           })
```

### Correlation between annotations: over entire spacer target

```{r guide_viral_structure, fig.height=8}
guide_structure <- sapply(seq(nrow(guide_features)),
                          function(x) {
                            region_start <- guide_features$start[x]
                            region_end <- region_start + nchar(guide_features$spacer[x]) - 1
                            region_features <- viral_genome[match(region_start:region_end,
                                                                  viral_genome$pos),]
                            region_annotations <- c(manfredonia = mean(region_features$manfredonia == "lowShannon/highSHAPE"),
                                                    lan = mean(region_features$lan == "unstructured"),
                                                    sun_invivo = mean(region_features$sun_invivo),
                                                    sun_invitro = mean(region_features$sun_invitro),
                                                    huston = mean(region_features$huston == 0),
                                                    invivo = mean(region_features$invivo == "unstructured"))
                            return(region_annotations)
                          })
guide_structure <- data.frame(t(guide_structure))
guide_structure$invivo_cat <- sapply(guide_structure$invivo,
                                     function(x) {
                                       ifelse(x==0,
                                              "DS",
                                              ifelse(x==1,
                                                     "SS",
                                                     "SS-DS"))
                                     })
guide_features <- cbind(guide_features, guide_structure)

manfredonia_lan <- plot_guide_feature_cor(guide_structure,
                                          "manfredonia", "Manfredonia",
                                          "lan", "Lan")
manfredonia_sun_invivo <- plot_guide_feature_cor(guide_structure,
                                                 "manfredonia", "Manfredonia",
                                                 "sun_invivo", "Sun (in vivo)")
manfredonia_sun_invitro <- plot_guide_feature_cor(guide_structure,
                                                  "manfredonia", "Manfredonia",
                                                  "sun_invitro", "Sun (in vitro)")
manfredonia_huston <- plot_guide_feature_cor(guide_structure,
                                             "manfredonia", "Manfredonia",
                                             "huston", "Huston")
lan_sun_invivo <- plot_guide_feature_cor(guide_structure,
                                         "lan", "Lan",
                                         "sun_invivo", "Sun (in vivo)",
                                         in_vivo=T)
lan_sun_invitro <- plot_guide_feature_cor(guide_structure,
                                          "lan", "Lan",
                                          "sun_invitro", "Sun (in vitro)")
lan_huston <- plot_guide_feature_cor(guide_structure,
                                     "lan", "Lan",
                                     "huston", "Huston",
                                     in_vivo=T)
sun_invivo_sun_invitro <- plot_guide_feature_cor(guide_structure,
                                                 "sun_invivo", "Sun (in vivo)",
                                                 "sun_invitro", "Sun (in vitro)")
sun_invivo_huston <- plot_guide_feature_cor(guide_structure,
                                            "sun_invivo", "Sun (in vivo)",
                                            "huston", "Huston",
                                            in_vivo=T)
sun_invitro_huston <- plot_guide_feature_cor(guide_structure,
                                             "sun_invitro", "Sun (in vitro)",
                                             "huston", "Huston")

manfredonia_huston + lan_huston + sun_invivo_huston + sun_invitro_huston +
  manfredonia_sun_invitro + lan_sun_invitro + sun_invivo_sun_invitro + plot_spacer() +
  manfredonia_sun_invivo + lan_sun_invivo + plot_spacer() + plot_spacer() +
  manfredonia_lan + plot_spacer() + plot_spacer() + plot_spacer()
```

* Annotations from Manffedonia (2020) correlate poorly with other annotations
    + Only 12% of genome is labeled
    + Experimental data generated on 500bp tiling of refolded viral genome
* Relatively high correlation between annotations generated from *in vivo* settings
    + Lan (2020)
    + Sun (2021)
    + Huston (2021)

### Intersection of *in vivo* viral structure predictions

```{r in_vivo_intersection, fig.height=4}
guide_features$lan_sun_huston <- sapply(seq(nrow(guide_features)),
                                        function(x) {
                                          tmp_sun <- guide_features$sun_invivo[x]
                                          tmp_huston <- guide_features$huston[x]
                                          tmp_lan <- guide_features$lan[x]
                                          if(tmp_sun > 0.25 & tmp_huston >= 0.75) {
                                            return("unstructured")
                                          } else {
                                            if(tmp_sun <= 0.25 & tmp_huston <= 0.25) {
                                              return("structured")
                                            } else {
                                              return("intermediate")
                                            }
                                          }
                                        })
guide_features$lan_sun_huston <- factor(guide_features$lan_sun_huston,
                                        levels=c("unstructured", "intermediate", "structured"))

ggplot(guide_features, aes(x=sun_invivo, y=huston, col=lan, shape=lan_sun_huston)) +
  geom_point() + theme_bw() + labs(col="Lan", shape="Structure (intersection)") + 
  xlab("Sun (in vivo)") + ylab("Huston")
```

### Correlation between annotations: over spacer seed region (positions 8-12 on spacer)

```{r guide_viral_structure_seed, fig.height=8}
guide_structure_seed <- sapply(seq(nrow(guide_features)),
                          function(x) {
                            region_start <- guide_features$start[x] + 7
                            region_end <- guide_features$start[x] + 11
                            region_features <- viral_genome[match(region_start:region_end,
                                                                  viral_genome$pos),]
                            region_annotations <- c(manfredonia = mean(region_features$manfredonia == "lowShannon/highSHAPE"),
                                                    lan = mean(region_features$lan == "unstructured"),
                                                    sun_invivo = mean(region_features$sun_invivo),
                                                    sun_invitro = mean(region_features$sun_invitro),
                                                    huston = mean(region_features$huston == 0))
                            return(region_annotations)
                          })
guide_structure_seed <- data.frame(t(guide_structure_seed))
colnames(guide_structure_seed) <- paste0(colnames(guide_structure_seed), "_seed")
guide_features <- cbind(guide_features, guide_structure_seed)

manfredonia_lan_seed <- plot_guide_feature_cor(guide_structure_seed,
                                          "manfredonia_seed", "Manfredonia",
                                          "lan_seed", "Lan")
manfredonia_sun_invivo_seed <- plot_guide_feature_cor(guide_structure_seed,
                                                 "manfredonia_seed", "Manfredonia",
                                                 "sun_invivo_seed", "Sun (in vivo)")
manfredonia_sun_invitro_seed <- plot_guide_feature_cor(guide_structure_seed,
                                                  "manfredonia_seed", "Manfredonia",
                                                  "sun_invitro_seed", "Sun (in vitro)")
manfredonia_huston_seed <- plot_guide_feature_cor(guide_structure_seed,
                                             "manfredonia_seed", "Manfredonia",
                                             "huston_seed", "Huston")
lan_sun_invivo_seed <- plot_guide_feature_cor(guide_structure_seed,
                                         "lan_seed", "Lan",
                                         "sun_invivo_seed", "Sun (in vivo)",
                                         in_vivo=T)
lan_sun_invitro_seed <- plot_guide_feature_cor(guide_structure_seed,
                                          "lan_seed", "Lan",
                                          "sun_invitro_seed", "Sun (in vitro)")
lan_huston_seed <- plot_guide_feature_cor(guide_structure_seed,
                                     "lan_seed", "Lan",
                                     "huston_seed", "Huston",
                                     in_vivo=T)
sun_invivo_sun_invitro_seed <- plot_guide_feature_cor(guide_structure_seed,
                                                 "sun_invivo_seed", "Sun (in vivo)",
                                                 "sun_invitro_seed", "Sun (in vitro)")
sun_invivo_huston_seed <- plot_guide_feature_cor(guide_structure_seed,
                                            "sun_invivo_seed", "Sun (in vivo)",
                                            "huston_seed", "Huston",
                                            in_vivo=T)
sun_invitro_huston_seed <- plot_guide_feature_cor(guide_structure_seed,
                                             "sun_invitro_seed", "Sun (in vitro)",
                                             "huston_seed", "Huston")

manfredonia_huston_seed + lan_huston_seed + sun_invivo_huston_seed + sun_invitro_huston_seed +
  manfredonia_sun_invitro_seed + lan_sun_invitro_seed + sun_invivo_sun_invitro_seed + plot_spacer() +
  manfredonia_sun_invivo_seed + lan_sun_invivo_seed + plot_spacer() + plot_spacer() +
  manfredonia_lan_seed + plot_spacer() + plot_spacer() + plot_spacer()
```

```{r in_vivo_kmeans}
set.seed(10)
invivo_kmeans_2 <- kmeans(guide_features[, c("lan", "sun_invivo", "huston")], 2)
invivo_kmeans_2_labels <- rank(rowMeans(invivo_kmeans_2$centers))
guide_features$invivo_kmeans_2 <- invivo_kmeans_2$cluster
guide_features$invivo_kmeans_2 <- as.factor(guide_features$invivo_kmeans_2)
levels(guide_features$invivo_kmeans_2) <- c("structured", "unstructured")[invivo_kmeans_2_labels]

set.seed(20)
invivo_kmeans_3 <- kmeans(guide_features[, c("lan", "sun_invivo", "huston")], 3)
invivo_kmeans_3_labels <- rank(rowMeans(invivo_kmeans_3$centers))
guide_features$invivo_kmeans_3 <- invivo_kmeans_3$cluster
guide_features$invivo_kmeans_3 <- as.factor(guide_features$invivo_kmeans_3)
levels(guide_features$invivo_kmeans_3) <- c("structured", "intermediate", "unstructured")[invivo_kmeans_3_labels]
```

```{r map_96_to_384}
mapping_384_to_96 <- data.frame(matrix(NA, nrow=16, ncol=24))
rownames(mapping_384_to_96) <- LETTERS[1:16]
for(x in 1:8) {
  for(y in 1:12) {
    tmp_rows <- c(2*x-1, 2*x-1, 2*x)
    tmp_cols <- c(2*y-1, 2*y, 2*y)
    tmp_label <- paste0(LETTERS[x], y)
    for(z in 1:3) {
      mapping_384_to_96[tmp_rows[z], tmp_cols[z]] <- tmp_label
    }
  }
}
mapping_384_to_96 <- data.frame(well_96 = unlist(mapping_384_to_96),
                                well_384 = paste0(rep(LETTERS[1:16], times=24),
                                                  rep(1:24, each=16)))
mapping_384_to_96[is.na(mapping_384_to_96)] <- "empty"
```

```{r load_platemaps}
expt_names <- c("GS1_1", "GS1_2", "GS2_1", "GS2_2", "GS3")
plate_maps <- xlsx::read.xlsx(file.path(project_dir, "AC_Guide_Screening.xlsx"),
                              sheetName="Plate Setups")
plate_maps <- subset(plate_maps, NA. %in% LETTERS[1:8])[, 3:14]
plate_maps <- split(plate_maps, rep(expt_names, each=8))
plate_maps <- lapply(seq_along(plate_maps),
                     function(x) {
                       if(x %in% 1:4) {
                         data.frame(sample = paste0(unlist(plate_maps[[x]]), 
                                                    rep(c("_noActivator", "_100fM"), each=48)),
                                    well_96 = paste0(rep(LETTERS[1:8], times=12),
                                                     rep(1:12, each=8)))
                       } else {
                         tmp_map <- data.frame(sample = paste0(unlist(plate_maps[[x]][1:4,]),
                                                               c(rep(rep(c("_noActivator", "_100fM"), 
                                                                         each=2),
                                                                     times=12))),
                                               well_96 = paste0(rep(LETTERS[1:4], times=12),
                                                                rep(1:12, each=4)))
                         return(subset(tmp_map, !grepl("NA", tmp_map$sample)))
                       }
                     })
names(plate_maps) <- expt_names
```

```{r load_plate_data}
data_dir <- file.path(project_dir, "100fM_data")
data_fnames <- list.files(data_dir)
plate_data <- lapply(data_fnames,
                     function(x) {
                       tmp_plate <- sub("_100fM_Plate", "", 
                                        sub("-", "_", 
                                            sub(".xlsx", "", x)))
                       row_indices <- 57:117
                       tmp_data <- xlsx::read.xlsx(file.path(data_dir, x), 
                                                   sheetIndex=1, rowIndex=row_indices, header=T)
                       tmp_data <- lapply(seq(nrow(tmp_data)),
                                          function(x) {
                                            data.frame(tmp_data[x, 1:3],
                                                       unlist(tmp_data[x, 4:387]),
                                                       colnames(tmp_data)[4:387],
                                                       row.names = NULL)
                                          })
                       tmp_data <- do.call(rbind, tmp_data)
                       colnames(tmp_data) <- c("cycle_number", "time", "temp", "signal", "well_384")
                       tmp_data$well_96 <- mapping_384_to_96$well_96[match(tmp_data$well_384,
                                                                           mapping_384_to_96$well_384)]
                       tmp_platemap <- plate_maps[[tmp_plate]]
                       tmp_data$sample <- tmp_platemap$sample[match(tmp_data$well_96,
                                                                    tmp_platemap$well_96)]
                       tmp_data$plate <- tmp_plate
                       return(tmp_data)
                     })
plate_data <- do.call(rbind, plate_data)
plate_data$guide_id <- sapply(plate_data$sample,
                              function(x) {
                                ifelse(grepl("_", x),
                                       sub(" ", "_", sub("_.*", "", x)),
                                       "empty")
                              })

plate_data$activator <- factor(sapply(plate_data$sample,
                                      function(x) {
                                        ifelse(grepl("_", x),
                                               sub(".*_", "", x),
                                               "empty")
                                      }), 
                               levels=c("100fM", "noActivator", "empty"))
plate_data$cycle_number <- as.numeric(plate_data$cycle_number)
plate_data$signal <- as.numeric(plate_data$signal)
plate_data$time <- plate_data$time/60 # convert from seconds to minutes
```

```{r background_subtract}
# background_empty <- mean(subset(plate_data, is.na(sample))$signal, na.rm=T)
# plate_data$signal_bkgdSubtract <- plate_data$signal - background_empty
background_empty <- aggregate(signal ~ cycle_number + plate, 
                              subset(plate_data, is.na(sample)), 
                              mean, na.rm=T)
plate_data$background <- background_empty$signal[row.match(plate_data[, c("cycle_number", "plate")],
                                                           background_empty[, c("cycle_number", "plate")])]
plate_data$signal_bkgdSubtract <- with(plate_data, signal - background)
plate_data <- subset(plate_data, !is.na(sample))
plate_data$activator <- droplevels(plate_data$activator)
```

# Exploratory data analysis: controls

## Plate controls: 612_Control and No_Protein

```{r analyze_plate_controls}
## plot controls: No_Protein and 612_Control
control_data <- subset(plate_data, 
                       guide_id %in% c("No_Protein", "612_Control"))
control_outliers <- rbind(subset(control_data,
                                 cycle_number==60 & 
                                   guide_id=="612_Control" & 
                                   signal_bkgdSubtract > 15000),
                          subset(control_data,
                                 cycle_number==60 &
                                   guide_id=="612_Control" &
                                   activator=="noActivator" &
                                   signal_bkgdSubtract > 4500),
                          subset(control_data,
                                 cycle_number==60 &
                                   guide_id=="No_Protein" &
                                   signal_bkgdSubtract > 3500))
control_data$group <- with(control_data, paste(plate, well_384, sep="_"))
ggplot(control_data, aes(x=time, y=signal_bkgdSubtract, col=plate)) +
  theme_bw() + xlab("time (min)") + ylab("background-subtracted fluorescence (RFU)") +
  geom_line(aes(group=group), alpha=0.5) + facet_grid(guide_id ~ activator) +
  geom_text(data=control_outliers, 
            aes(x=time, y=signal_bkgdSubtract, label=well_384),
            nudge_x=-5, col="black", size=2)
```

* Plate GS2-2 outliers: O 9-12, 21-24
* No_Protein (+/- activator) and 612_Control (- activator) controls cluster tightly across plates
* Variable spread of 612_Control activity with 100 fM activator

## RNP-only controls

```{r analyze_noActivator, fig.height=7}
noActivator_data <- subset(plate_data, activator=="noActivator")
noActivator_outliers <- rbind(subset(noActivator_data,
                                     cycle_number==60 &
                                       plate=="GS1_2" &
                                       signal_bkgdSubtract > 9000),
                              subset(noActivator_data,
                                     cycle_number==60 &
                                       plate=="GS2_1" &
                                       signal_bkgdSubtract > 10000),
                              subset(noActivator_data,
                                     plate=="GS2_1" &
                                       cycle_number==23 &
                                       signal_bkgdSubtract > 60000))
# calculate rates per guide
noActivator_rates <- split(noActivator_data, noActivator_data$guide_id)
noActivator_rates <- sapply(noActivator_rates, compute_rate)
noActivator_rates <- data.frame(guide_id=sub(".time", "", names(noActivator_rates)),
                                rate=noActivator_rates,
                                row.names=NULL)
noActivator_rates$plate <- noActivator_data$plate[match(noActivator_rates$guide_id,
                                                        noActivator_data$guide_id)]
# plot
(ggplot(noActivator_data, aes(x=time, y=signal_bkgdSubtract, col=plate)) +
    theme_bw() + xlab("time (min)") + ylab("background-subtracted fluoresence (RFU)") +
    geom_line(aes(group=well_384), alpha=0.5) + facet_grid(~plate) +
    geom_text(data=noActivator_outliers,
              aes(x=time, y=signal_bkgdSubtract, label=well_384), col="black") +
    theme(legend.position="none")) /
  (ggplot(noActivator_rates, aes(x=plate, y=rate, fill=plate)) +
     geom_violin() + theme_bw() + xlab("") + theme(legend.position="none") +
     ylim(-5, 30) + ggtitle("", subtitle="removing outliers")) +
  plot_layout(heights=c(2,1))
```

* RNP-only control varies by plate (and presumably by guide) 
+ Want to be able to account for additional gain in activator-dependent rate background
* Outliers on plate GS2-1 all correspond to NCR_1344

```{r NCR_1344_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1344.png")))
```

# Data analysis

## Methods:

* Mixed linear regression to compute rate per condition across triplicates:
    + per guide: $\text{signal}_i(t) = (\beta_0 + \beta_{0,i}) + (\beta_{\text{100fM}}\cdot\mathbb{I}[\text{100fM}]) \ + (\beta_{t} + \beta_{t,i}) \cdot t \ + (\beta_{t:\text{100fM}}\cdot t\cdot\mathbb{I}[\text{100fM}])$
    + RNP-only: $\text{signal}_i(t) = (\beta_0 + \beta_{0,i}) +  (\beta_t + \beta_{t,i}) \cdot t_i$
    + 100fM activator: $\text{signal}_i(t) = (\beta_0 + \beta_{0,i} + \beta_{\text{100fM}}) + (\beta_t + \beta_{t,i} +  \beta_{t:\text{100fM}}) \cdot t_i$
    + 100fM activator-dependent rate: $\beta_{t:\text{100fM}}$
* Background subtract mean of empty wells
* Exclude timepoints before 1000 seconds (first 10 timepoints show dip in some RNP-only controls)
* Random effects (per 384-well, across timepoints): intercept, slope (wrt time)
* Fixed effects: intercepts ($\beta_0$, $\beta_{\text{100fM}}$), slopes ($\beta_t$, $\beta_{t:\text{100fM}}$)

```{r analyze_data}
guide_ids <- unique(plate_data$guide_id)
guide_ids <- guide_ids[!(guide_ids %in% c("612_Control", "No_Protein"))]
all_results <- lapply(guide_ids,
                      function(x) {
                        tmp <- try(analyze_guide(plate_data, guide=x, time_start=15,
                                                 signal="signal_bkgdSubtract",
                                                 mixed_model=mixed),
                                   silent=T)
                        if(class(tmp) == "try-error") {
                          print(paste0("mixed model failed: NCR_", x))
                          tmp <- analyze_guide(plate_data, guide=x, time_start=15, 
                                               signal="signal_bkgdSubtract",
                                               mixed_model=F)
                          return(tmp)
                        } else {
                          return(tmp)
                        }
                      })
names(all_results) <- guide_ids
all_plots <- lapply(seq_along(all_results),
                    function(x) {
                      guide_id <- paste0("NCR_", names(all_results)[x])
                      which_row <- match(guide_id, guide_features$NCR.id)
                      has_hairpin <- guide_features$has_crRNA_hairpin[which_row]
                      spacer_bp <- guide_features$crRNA_spacer_basepairs[which_row]
                      plot_subtitle <- paste(ifelse(has_hairpin, "has hairpin", "no hairpin"), "|",
                                             spacer_bp, "basepaired positions in spacer")
                      all_results[[x]]$plot + ggtitle(guide_id, subtitle=plot_subtitle)
                    })
names(all_plots) <- guide_ids
# plots_by_group <- split(all_plots, 
#                         guide_features$group[match(paste0("NCR_", names(all_plots)),
#                                                    guide_features$NCR.id)])
```

```{r save_viral_traces, message=F}
trace_viral_dir <- file.path(traces_dir, "viral")
if(!dir.exists(trace_viral_dir)) { dir.create(trace_viral_dir) }
for(x in seq_along(all_plots)) {
  ggsave(filename=file.path(trace_viral_dir, 
                            paste0("NCR_", names(all_plots)[x], ".pdf")),
         plot=all_plots[[x]], device="pdf")
}
```

### Example traces:

* dots: signal per 384-well per time
* solid lines: regression fit

```{r example_traces, fig.height=8}
all_plots[["522"]] / all_plots[["527"]]
```

```{r NCR_1324_structure, fig.height=8, include=F}
NCR_1324_noOutlier <- subset(plate_data, guide_id=="1324")
NCR_1324_outlierWell <- NCR_1324_noOutlier$well_384[which.max(NCR_1324_noOutlier$signal_bkgdSubtract)]
NCR_1324_noOutlier <- subset(NCR_1324_noOutlier, well_384 != NCR_1324_outlierWell)
NCR_1324_noOutlier_results <- analyze_guide(NCR_1324_noOutlier, guide="1324", mixed_model=mixed)
all_plots[["1324"]] / (NCR_1324_noOutlier_results$plot + ggtitle("NCR_1324", subtitle="remove outlier"))
all_results[["1324"]] <- NCR_1324_noOutlier_results
```

```{r aggregate_coefficients}
all_coef <- lapply(all_results, function(x) x$coef)
all_coef <- do.call(rbind, all_coef)
all_coef <- cbind(all_coef,
                  guide_features[match(paste0("NCR_", all_coef$guide_id),
                                       guide_features$NCR.id),])
all_coef$plate <- plate_data$plate[match(all_coef$guide_id, plate_data$guide_id)]

guide_rate <- subset(all_coef, grepl(":", all_coef$coef))
```

```{r compute_100fM_rate}
guide_rate_100fM <- aggregate(Estimate ~ guide_id, 
                              data=subset(all_coef, grepl("time", all_coef$coef)),
                              FUN=sum)
guide_rate_100fM <- cbind(guide_rate_100fM,
                          guide_features[match(paste0("NCR_", guide_rate_100fM$guide_id),
                                               guide_features$NCR.id),])
```

## Results: 100 fM rates (above RNP-only control)

### Summary of screen

```{r plot_rates, fig.height=16}
ggplot(guide_rate, aes(x=Estimate, y=guide_id, col=plate)) + geom_point() +
  geom_errorbar(aes(xmin=Estimate-qnorm(0.05)*Std.Error,
                    xmax=Estimate+qnorm(0.05)*Std.Error)) + 
  theme_bw() + geom_vline(xintercept=0,) + theme(axis.text.y=element_text(size=6)) + 
  xlab("activator-dependent rate\n(RFU/min)") + ylab("guide id")

# rotated plot
# ggplot(guide_rate, aes(x=guide_id, y=Estimate, col=plate)) + geom_point() +
#   geom_errorbar(aes(ymin=Estimate-qnorm(0.05)*Std.Error, 
#                     ymax=Estimate+qnorm(0.05)*Std.Error)) + 
#   theme_bw() + geom_hline(yintercept=0) + scale_x_discrete(limits=rev) +
#   theme(axis.text.x=element_text(angle=90, size=6, hjust=1, vjust=0.5)) + 
#   xlab("") + ylab("activator-dependent rate\n(RFU/min)")
```

```{r exclude_1344_outlier, eval=F}
guide_rate <- subset(guide_rate, guide_id != "1344")
```

* Similar spread of rates across plates
+ Expect to see poorer rates for plates GS2-1 and GS2-2 (which harbor the "bad" guides)

### Detection at last timepoint

```{r detection_last_timepoint}
ttest_lasttimepoint <- lapply(guide_rate$guide_id,
                              function(x) {
                                tmp_data <- subset(plate_data, 
                                                   cycle_number==60 &
                                                     guide_id==x)
                                t.test(signal_bkgdSubtract ~ activator,
                                       data=tmp_data)
                              })
guide_rate$ttest_t <- sapply(ttest_lasttimepoint, function(x) x$statistic)
guide_rate$ttest_pvalue <- sapply(ttest_lasttimepoint, function(x) x$p.value)
guide_rate$detectable <- factor(ifelse(p.adjust(guide_rate$ttest_pvalue, 
                                         method="fdr")<0.05,
                                "detectable", "undetectable"),
                                levels=c("undetectable", "detectable"))

ggplot(subset(guide_rate, crRNA_spacer_basepairs %in% c(0, 4, 10, 16)),
       aes(x=detectable, y=Estimate)) + 
  geom_violin(aes(fill=detectable), alpha=0.25,
              draw_quantiles=c(0.25, 0.75), linetype="dashed") + 
  geom_violin(fill="transparent", draw_quantiles=0.5) + 
  geom_dotplot(binaxis="y", stackdir="center", binwidth=1) + 
  facet_grid(~ factor(crRNA_spacer_basepairs, levels=c(0, 4, 10, 16))) + 
  theme_bw() + xlab("") + ylab("activator-dependent rate\n(RFU/min)") + 
  geom_label(aes(x=x, y=y, label=text),
            data=data.frame(x=Inf, y=Inf, crRNA_spacer_basepairs=c(0, 4, 10, 16),
                            text=paste("p =",
                                       sapply(c(0, 4, 10, 16), 
                                                     function(x) 
                                                       signif(wilcox.test(Estimate ~ detectable, 
                                                                   subset(guide_rate, 
                                                                          crRNA_spacer_basepairs==x))$p.value,
                                                              digits=3)))),
            col="red", hjust="inward", vjust="inward")

ggplot_violin(guide_rate, x_var="detectable") + 
  annotate(geom="label", x=Inf, y=Inf, col="red", hjust="inward", vjust="inward",
           label=paste("p =", signif(wilcox.test(Estimate ~ detectable, 
                                                 data=guide_rate)$p.value, 
                                     digits=3)))
```

### Time to detection

Per guide:
* Per timepoint: t-test for difference in signal between RNP-only and 100 fM conditions per timepoint
* Perform FDR correction for number of measurements from start of experiment to timepoint
* Return first timepoint for which corrected p-value < 0.05

```{r time_to_detection}
guide_rate$time_to_detection <- sapply(guide_rate$guide_id,
                                       function(x)  {
                                         compute_detection_time(plate_data, x) 
                                       })
guide_rate$has_detection_time <- !is.na(guide_rate$time_to_detection)

(ggplot(subset(guide_rate, !is.na(time_to_detection)),
               aes(x=Estimate, y=time_to_detection)) + 
   geom_jitter(alpha=0.5) + geom_smooth(method=lm, formula=y~x) + 
   theme_bw() + xlab("activator-dependent rate\n(RFU/min)") + 
   ylab("time to detection (min)") + 
   ggtitle("Time to detection",
           subtitle=paste("Number of detectable guides:",
                          sum(!is.na(guide_rate$time_to_detection))))) + 
  (ggplot_violin(guide_rate, x_var="has_detection_time") + 
     labs(fill="detection time  2h") + 
     annotate(geom="text", x=Inf, y=Inf, col="red", hjust="inward", vjust="inward",
              label=paste("p =", signif(t.test(Estimate ~ has_detection_time, 
                                               data=guide_rate)$p.value, 
                                        digits=3))))
```

### Volcano plots of screening rates

```{r plot_rate_volcano}
ggplot(guide_rate, aes(x=Estimate, y=-log10(p.value), 
                       col=plate, shape=detectable)) + 
  geom_point() + theme_bw() + 
  xlab("activator-dependent rate\n(RFU/min)") + ylab("-log10(p)") +
  geom_hline(yintercept=-log10(0.05/nrow(guide_rate)), col="red", linetype="dashed")
```

* Guides on plate GS2-2 have similar rates as to other plates, but are much more variable (p-values closer to 1)

### Rates by position along SARS-CoV-2 genome

```{r rate_by_position}
ggplot(guide_rate, aes(x=start, y=Estimate, col=crRNA_spacer_basepairs, 
                       shape=has_crRNA_hairpin)) + 
  geom_point(size=2, alpha=0.8) + theme_bw() + 
  xlab("genomic position") + ylab("activator-dependent rate\n(RFU/min)")
```

Structures of the two guides that performed well (rate > 1 above background) but without hairpin structure (NCR_1346, NCR_1351):

```{r NCR_1346_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1346.png")))
```

```{r NCR_1351_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1351.png")))
```

### Rates across groups of guide secondary structure

```{r rate_by_spacer_structure}
guide_rate$spacer_bp <- as.numeric(as.character(guide_rate$crRNA_spacer_basepairs))
spacer_structure_cor <- with(guide_rate, cor.test(Estimate, spacer_bp))
ggplot(guide_rate, aes(x=spacer_bp, y=Estimate)) + geom_point() + 
  geom_smooth(method=lm, formula=y~x) + theme_bw() +
  xlab("number of basepaired positions in spacer") + 
  ylab("activator-dependent rate\n(RFU/min)") +
  annotate(geom="text", x=0.5, y=-15, 
           label=paste("cor =", round(spacer_structure_cor$estimate, digits=3))) +
  annotate(geom="text", x=0.5, y=-20,
           label=paste("p =", round(spacer_structure_cor$p.value, digits=3))) 
```

* Statistically significant (positive?) correlation between guide activity and spacer structure

```{r rate_by_guidegroup}
ggplot_violin(subset(guide_rate, crRNA_spacer_basepairs %in% c(0, 4, 10, 16)),
              x_var="group", fill_var="has_crRNA_hairpin") + 
  theme(axis.text.x=element_text(angle=90, hjust=1))
```

Determination of how much of predicted hairpin structure needs to be maintained:

```{r hairpin_structure, fig.height=22.5}
hairpin_length <- nchar(guide_features$structure[1]) - 20
good_hairpin <- substr(guide_features$structure[1], 1, hairpin_length)

maintain_hairpin <- sapply(24:hairpin_length,
                           function(x) {
                             good_structure <- substr(good_hairpin, 1, x)
                             tmp_structures <- substr(guide_rate$structure, 1, x)
                             return(tmp_structures == good_structure)
                           })
maintain_hairpin <- data.frame(cbind(guide_rate[, c("guide_id", "start", 
                                                    "Estimate", "crRNA_spacer_basepairs")],
                                     maintain_hairpin))
colnames(maintain_hairpin)[grepl("^X", colnames(maintain_hairpin))] <- paste0("first_", 24:hairpin_length)

maintain_hairpin_noOutliers <- subset(maintain_hairpin, !(guide_id %in% c(1346, 1351)))

maintain_hairpin_plots <- lapply(24:hairpin_length,
                                 function(x) {
                                   hairpin_length <- paste0("first_", x)
                                   tmp_wilcox <- wilcox.test(formula(paste("Estimate ~", 
                                                                           hairpin_length)),
                                                             data=maintain_hairpin_noOutliers)
                                   ggplot_violin(subset(maintain_hairpin_noOutliers,
                                                        crRNA_spacer_basepairs %in% c(0, 4, 10, 16)),
                                                 x_var=hairpin_length, fill_var="crRNA_spacer_basepairs",
                                                 x_lab="maintain hairpin") +
                                     ggtitle("", subtitle=paste("first", x, "bases")) +
                                     annotate(geom="text", x=T, y=80, 
                                              label=paste("p =", round(tmp_wilcox$p.value, digits=3)))
                                 })
wrap_plots(maintain_hairpin_plots, ncol=1, byrow=T)
```

```{r bad_hairpin}
bad_hairpin <- subset(maintain_hairpin, !first_24)$guide_id
subset(guide_features, NCR.id %in% paste0("NCR_", bad_hairpin))[, c("NCR.id", "spacer", "structure")]
```

```{r NCR_1313_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1313.png")))
```

```{r NCR_1319_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1319.png")))
```

```{r NCR_1332_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1332.png")))
```

```{r NCR_1335_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1335.png")))
```

```{r NCR_1348_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1348.png")))
```

```{r NCR_1349_structure}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1349.png")))
```

```{r NCR_1351_structure_2}
knitr::include_graphics(path.expand(file.path(structure_dir, "NCR_1351.png")))
```

* "Good" guides exhibit similar 100fM rates as "bad" guides

### Rates across guide ordering group

```{r rate_by_class, fig.height=8}
(ggplot_violin(guide_rate, x_var="class") +
   guides(fill="none") + theme(axis.text.x=element_text(angle=90, hjust=1))) / 
  (ggplot_violin(guide_rate_100fM, x_var="class", y_lab="100fM rate (RFU/min)") + 
     guides(fill="none") + theme(axis.text.x=element_text(angle=90, hjust=1)))
```

### Background (RNP-only) rate by guide secondary structure

```{r noActivator_rates}
noActivator_rate <- subset(all_coef, coef=="time")
noActivator_rate <- subset(noActivator_rate, guide_id != "1344")
ggplot_violin(subset(noActivator_rate, crRNA_spacer_basepairs %in% c(0, 4, 10, 16)),
              x_var="group", fill_var="has_crRNA_hairpin",
              y_lab="activator-independent activity (RFU/min)", binwidth=0.25) +
  labs(fill="maintains crRNA hairpin") +
  theme(axis.text.x=element_text(angle=90, hjust=1))
```

* In guides that maintain crRNA hairpin: correlation between number of basepaired positions in spacer and background RNP-only rate

### Other analyses

```{r rate_by_gc_content}
ggplot(guide_rate, aes(x=GC_content, y=Estimate)) + 
  geom_point() + geom_smooth(method="lm", formula=y~x) + theme_bw() + 
  xlab("GC content (%)") + ylab("activator-dependent rate\n(RFU/min)") +
  annotate(geom="text", x=Inf, y=75, hjust="inward", vjust="inward", col="red",
           label=bquote(rho~"="~.(round(with(guide_rate, 
                                             cor.test(GC_content, 
                                                      Estimate,
                                                      method="spearman"))$estimate, 
                                        digits=3)))) + 
  annotate(geom="text", x=Inf, y=65, hjust="inward", vjust="inward", col="red",
           label=bquote("p ="~.(round(with(guide_rate, 
                                           cor.test(GC_content, 
                                                    Estimate,
                                                    method="spearman"))$p.value, 
                                      digits=3))))
```

* Weak negative correlation between spacer GC content and guide activity

```{r rate_by_downstream_U}
(ggplot(guide_rate, aes(x=downstream_U, y=Estimate)) + 
   geom_point() + geom_smooth(method="lm", formula=y~x) + theme_bw() + 
   xlab(paste0("% U in downstream ", U_window, "nt in viral genome")) + 
   ylab("activator-dependent rate\n(RFU/min)") +
   annotate(geom="text", x=Inf, y=75, hjust="inward", vjust="inward", col="red",
            label=bquote(rho~"="~.(round(with(guide_rate, 
                                              cor.test(downstream_U, 
                                                       Estimate,
                                                       method="spearman"))$estimate, 
                                         digits=3)))) + 
   annotate(geom="text", x=Inf, y=65, hjust="inward", vjust="inward", col="red",
            label=bquote("p ="~.(round(with(guide_rate, 
                                            cor.test(downstream_U, 
                                                     Estimate,
                                                     method="spearman"))$p.value, 
                                       digits=3))))) + 
  (ggplot(guide_rate, aes(x=downstream_unstructured_U, y=Estimate)) + 
     geom_point() + geom_smooth(method="lm", formula=y~x) + theme_bw() + 
     xlab(paste0("% unstructured U in downstream ", U_window, "nt in viral genome")) + 
     ylab("activator-dependent rate\n(RFU/min)") +
     annotate(geom="text", x=Inf, y=75, hjust="inward", vjust="inward", col="red",
              label=bquote(rho~"="~.(round(with(guide_rate, 
                                                cor.test(downstream_unstructured_U, 
                                                         Estimate,
                                                         method="spearman"))$estimate, 
                                           digits=3)))) + 
     annotate(geom="text", x=Inf, y=65, hjust="inward", vjust="inward", col="red",
              label=bquote("p ="~.(round(with(guide_rate, 
                                              cor.test(downstream_unstructured_U, 
                                                       Estimate,
                                                       method="spearman"))$p.value, 
                                         digits=3)))))
```

* Weak positive correlation between % unstructured U in 30 nt downstream of protospacer in viral genome and guide activity

```{r rate_by_gRNA_MFE}
ggplot(guide_rate, aes(x=gRNA_MFE, y=Estimate)) + 
  geom_point() + geom_smooth(method="lm", formula=y~x) + theme_bw() + 
  xlab("gRNA MFE (kcal/mol)") + ylab("activator-dependent rate\n(RFU/min)") +
  annotate(geom="text", x=-Inf, y=75, hjust="inward", vjust="inward", col="red",
           label=bquote(rho~"="~.(round(with(guide_rate, 
                                             cor.test(gRNA_MFE, 
                                                      Estimate,
                                                      method="spearman"))$estimate, 
                                        digits=3)))) + 
  annotate(geom="text", x=-Inf, y=65, hjust="inward", vjust="inward", col="red",
           label=bquote("p ="~.(round(with(guide_rate, 
                                           cor.test(gRNA_MFE, 
                                                    Estimate,
                                                    method="spearman"))$p.value, 
                                      digits=3))))
```

## Comparison of 20mers to 28mers

```{r adapt_comparison}
guide_rate_adapt <- rbind(data.frame(adapt_28mer,
                                     rate=guide_rate$Estimate[match(adapt_28mer$Original.Name,
                                                                    paste0("NCR_", guide_rate$guide_id))],
                                     spacer="20mer"),
                          data.frame(adapt_28mer,
                                     rate=guide_rate$Estimate[match(adapt_28mer$New.Name,
                                                                    paste0("NCR_", guide_rate$guide_id))],
                                     spacer="28mer"))
ggplot(guide_rate_adapt, aes(x=guide.expected.activities, y=rate, col=spacer)) + 
  geom_point() + geom_smooth(method="lm", formula=y~x) + theme_bw() +
  xlab("ADAPT prediction") + ylab("activator-dependent rate\n(RFU/min)")
```

## Guide activity by viral structure

```{r rate_by_viral_structure}
# Manfredonia (2020)
guide_rate$manfredonia_cat <- cut(guide_rate$manfredonia, 
                                  breaks=c(0, 0.04, 0.96, 1),
                                  include.lowest=T, right=F,
                                  labels=c("0%", "5-95%", "100%"))
manfredonia_anova <- anova(lm(Estimate~manfredonia_cat, data=guide_rate))
manfredonia_plot <- ggplot_violin(guide_rate, x_var="manfredonia_cat",
                                  x_lab="% basepaired positions in viral target") +
  guides(fill="none") + ggtitle("Manfredonia (2020)", subtitle="Persistent single-strandedness")

# Lan (2020)
guide_rate$lan_cat <- cut(guide_rate$lan,
                          breaks=c(0, 0.04, 0.5, 0.96, 1),
                          include.lowest=T, right=F,
                          labels=c("0%", "5-49%", "50-95%", "100%"))
lan_fit <- data.frame(summary(lm(Estimate~lan_cat, data=guide_rate))$coefficients)
lan_wilcox <- with(guide_rate,
                   wilcox.test(Estimate[lan_cat=="0%"],
                               Estimate[lan_cat=="50-95%"]))
lan_plot <- (ggplot(guide_rate, aes(x=lan, y=Estimate)) + 
               geom_point() + geom_smooth(method=loess, formula=y~x) + theme_bw() + 
               xlab("% unstructured positions in viral target") + 
               ylab("activator-dependent rate\n(RFU/min)") +
               ggtitle("Lan (2020)", subtitle="Unstructured region")) + 
  (ggplot_violin(guide_rate, x_var="lan_cat",
                 x_lab="% unstructured positions in viral target") + 
     annotate(geom="text", x="50-95%", y=80, 
              label=paste("* p=", round(lan_wilcox$p.value, digits=3))))
lan_spacer_bp_fit <- lm(Estimate~spacer_bp+lan_cat, data=guide_rate)
lan_spacer_bp_coef <- data.frame(summary(lan_spacer_bp_fit)$coefficients)
lan_spacer_bp_coef$coef <- rownames(lan_spacer_bp_coef)
lan_spacer_bp_data <- guide_rate[, c("Estimate", "spacer_bp", "lan", "lan_cat")]
lan_spacer_bp_data$rate <- with(lan_spacer_bp_data,
                                Estimate - spacer_bp*lan_spacer_bp_coef$Estimate[2])
lan_spacer_bp_wilcox <- with(lan_spacer_bp_data,
                             wilcox.test(rate[lan_cat=="0%"],
                                         rate[lan_cat=="50-95%"]))
lan_spacer_bp_plot <- ((ggplot(guide_rate, aes(x=spacer_bp, y=Estimate)) + 
                          geom_point() + 
                          geom_smooth(method=lm, formula=y~x) + theme_bw() +
                          xlab("number of basepaired positions in spacer") + 
                          ylab("activator-dependent rate\n(RFU/min)") +
                          annotate(geom="text", x=1, y=-15, 
                                   label=paste("cor =", 
                                               round(spacer_structure_cor$estimate, 
                                                     digits=3))) +
                          annotate(geom="text", x=1, y=-20,
                                   label=paste("p =", 
                                               round(spacer_structure_cor$p.value, 
                                                     digits=3))) +
                          ggtitle("rate ~ spacer structure")) /
                         (ggplot_violin(guide_rate, x_var="lan_cat", y_var="spacer_bp",
                                        x_lab="% unstructured positions in viral target",
                                        y_lab="number of basepaired positions in spacer") +
                            guides(fill="none") + ggtitle("spacer structure ~ target structure"))) | 
  (ggplot(subset(lan_spacer_bp_coef, coef != "(Intercept)"),
          aes(x=Estimate, y=coef)) + geom_point() + theme_bw() +
     geom_errorbar(aes(xmin=Estimate+qnorm(0.05)*Std..Error,
                       xmax=Estimate-qnorm(0.05)*Std..Error)) +
     geom_vline(xintercept=0, linetype="dashed") + 
     xlab("regression coefficient") + ylab("") +
     ggtitle("rate ~ spacer structure + target structure")) | 
  (ggplot_violin(lan_spacer_bp_data, x_var="lan_cat", y_var="rate", 
                 x_lab="% unstructured positions in viral target") +
     guides(fill="none") + ggtitle("rate ~ target structure", 
                              subtitle="controlled for spacer structure") +
     annotate(geom="text", x="50-95%", y=80,
              label=paste("* p =", round(lan_spacer_bp_wilcox$p.value, digits=3))))

# Sun (2021)
guide_rate$sun_invivo_cat <- cut(guide_rate$sun_invivo,
                                 breaks=quantile(guide_rate$sun_invivo, 
                                                 probs=c(0, 0.25, 0.50, 0.75, 1)),
                                 include.lowest=T,
                                 labels=c("Q1", "Q2", "Q3", "Q4"))
guide_rate$sun_invitro_cat <- cut(guide_rate$sun_invitro,
                                 breaks=quantile(guide_rate$sun_invitro, 
                                                 probs=c(0, 0.25, 0.50, 0.75, 1)),
                                 include.lowest=T,
                                 labels=c("Q1", "Q2", "Q3", "Q4"))
sun_plot <- (ggplot_violin(guide_rate, x_var="sun_invivo_cat", 
                           x_lab="quartiles of mean(icSHAPE) across viral target") +
               guides(fill="none") + ggtitle("Sun (2021)", subtitle="in vivo")) +
  (ggplot_violin(guide_rate, x_var="sun_invitro_cat", 
                 x_lab="quartiles of mean(icSHAPE) across viral target") + 
     guides(fill="none") + ggtitle("", subtitle="in vitro"))

# Huston (2021)
guide_rate$huston_cat <- cut(guide_rate$huston,
                             breaks=c(0, 0.2, 0.4, 0.6, 0.8, 1),
                             include.lowest=T,
                             labels=c("0-19%", "20-39%", "40-59%", "60-79%", "80-100%"))
huston_fit <- data.frame(summary(lm(Estimate ~ huston_cat, 
                                    data=guide_rate))$coefficients)
huston_wilcox <- with(guide_rate,
                      wilcox.test(Estimate[huston_cat=="0-19%"], 
                                  Estimate[huston_cat=="40-59%"]))
huston_plot <- (ggplot(guide_rate, aes(x=huston, y=Estimate)) + 
    geom_point() + geom_smooth(method=loess, formula=y~x) + theme_bw() + 
    xlab("% unbound positions in viral target") + 
    ylab("activator-dependent rate\n(RFU/min)") +
    ggtitle("Huston (2021)", subtitle="Viral RNA secondary structure")) + 
  (ggplot_violin(guide_rate, x_var="huston_cat", 
                 x_lab="% unbound positions in viral target") + 
     guides(fill="none") + annotate(geom="text", x="40-59%", y=80,
                               label=paste("* p =", round(huston_wilcox$p.value, digits=3))))

lan_plot
lan_spacer_bp_plot
huston_plot
manfredonia_plot + sun_plot + plot_layout(widths=c(1,2))
```

* Correlation between viral structure as annotated by Lan (2020)
    + But no correlation with other *in vivo* annotations (Sun and Huston)

```{r rate_by_viral_structure_intersection, fig.height=4}
(ggplot(guide_rate, aes(x=sun_invivo, y=huston, col=lan, shape=lan_sun_huston)) + 
  geom_point(alpha=0.75) + theme_bw() + 
  xlab("Sun (in vivo)") + ylab("Huston") + labs(col="Lan", shape="Intersection")) +
  (ggplot_violin(guide_rate, x_var="lan_sun_huston") + 
     guides(fill="none"))
```

### k-means clustering of in vivo structures (Lan, Sun, Huston)

```{r rate_by_viral_structure_kmeans, fig.height=8}
invivo_kmeans_2_wilcox <- wilcox.test(Estimate ~ invivo_kmeans_2, 
                                      data=guide_rate)
invivo_kmeans_3_wilcox <- wilcox.test(Estimate ~ invivo_kmeans_3,
                                      data=subset(guide_rate,
                                                  invivo_kmeans_3 %in% c("structured", "unstructured")))

# (fviz_cluster(invivo_kmeans_3,
#               data=guide_features[, c("lan", "sun_invivo", "huston")],
#               geom="point", ellipse.type="confidence") +
#     theme_bw() + guides(col="none", shape="none") +
#     scale_fill_discrete(labels=c("structured", "intermediate", "unstructured")[invivo_kmeans_3_labels]))
# (ggplot(guide_rate, aes(x=invivo_kmeans_3, y=Estimate)) + theme_bw() +
#         geom_violin(aes(fill=invivo_kmeans_3), alpha=0.5, 
#                     draw_quantiles=c(0.25, 0.75), linetype="dashed") +
#         geom_violin(fill="transparent", draw_quantiles=0.5) + 
#         geom_dotplot(binaxis="y", stackdir="center", binwidth=1) + guides(fill="none") + 
#         xlab("") + ylab("activator-dependent rate\n(RFU/min)") +
#         ggtitle("Guide activity v. viral genome structure", subtitle="k means: 3 clusters") +
#         annotate(geom="text", x= "unstructured", y=80, 
#                  label=paste("p =", round(invivo_kmeans_3_wilcox$p.value, 
#                                           digits=3))))

((fviz_nbclust(guide_features[, c("lan", "sun_invivo", "huston")], 
               kmeans, method="silhouette")) + 
    (fviz_cluster(invivo_kmeans_2, 
                  data=guide_features[, c("lan", "sun_invivo", "huston")], 
                  geom="point", ellipse.type="confidence") + 
       theme_bw() + guides(col="none", shape="none") + 
       scale_fill_discrete(labels=c("structured", "unstructured")[invivo_kmeans_2_labels]))) /
  (ggplot_violin(guide_rate, x_var="invivo_kmeans_2") + guides(fill="none") + 
     ggtitle("k-means clustering of in vivo viral structure (Lan, Sun, Huston)",
             subtitle="k = 2") +
     annotate(geom="text", x="unstructured", y=80,
              label=paste("p =", round(invivo_kmeans_2_wilcox$p.value,
                                       digits=3))))
```

### Restriction to spacer seed region (positions 8-12 on spacer)

```{r rate_by_viral_structure_seed, fig.height=8}
# Manfredonia (2020)
guide_rate$manfredonia_seed_cat <- ifelse(guide_rate$manfredonia_seed==1,
                                          "unstructured",
                                          ifelse(guide_rate$manfredonia_seed==0,
                                                 "structured",
                                                 "intermediate"))
guide_rate$manfredonia_seed_cat <- factor(guide_rate$manfredonia_seed_cat,
                                          levels=c("structured", "intermediate", "unstructured"))
manfredonia_seed_plot <- ggplot_violin(guide_rate, x_var="manfredonia_seed_cat") + 
  ggtitle("Manfredonia (2020): spacer seed region") + guides(fill="none")

# Lan (2020)
guide_rate$lan_seed_cat <- ifelse(guide_rate$lan_seed==1,
                                  "unstructured",
                                  ifelse(guide_rate$lan_seed==0,
                                         "structured",
                                         "intermediate"))
guide_rate$lan_seed_cat <- factor(guide_rate$lan_seed_cat,
                                  levels=c("structured", "intermediate", "unstructured"))
lan_seed_plot <- ggplot_violin(guide_rate, x_var="lan_seed_cat") + 
  ggtitle("Lan (2020): spacer seed region") + guides(fill="none")

# Sun (2021): in vitro
sun_invitro_seed_cat <- kmeans(guide_rate$sun_invitro_seed, 2)
guide_rate$sun_invitro_seed_cat <- factor(sun_invitro_seed_cat$cluster)
levels(guide_rate$sun_invitro_seed_cat) <- c("structured", "unstructured")[rank(sun_invitro_seed_cat$centers)]
sun_invitro_seed_plot <- ggplot_violin(guide_rate, x_var="sun_invitro_seed_cat") + 
  ggtitle("Sun (2020): in vitro: spacer seed region") + guides(fill="none")

# Sun (2021): in vivo
sun_invivo_seed_cat <- kmeans(guide_rate$sun_invivo_seed, 2)
guide_rate$sun_invivo_seed_cat <- factor(sun_invivo_seed_cat$cluster)
levels(guide_rate$sun_invivo_seed_cat) <- c("structured", "unstructured")[rank(sun_invivo_seed_cat$centers)]
sun_invivo_seed_plot <- ggplot_violin(guide_rate, x_var="sun_invivo_seed_cat") +
  ggtitle("Sun (2020): in vivo: spacer seed region") + guides(fill="none")

# Huston (2021)
guide_rate$huston_seed <- as.factor(guide_rate$huston_seed)
huston_seed_plot <- ggplot_violin(guide_rate, x_var="huston_seed") + 
  ggtitle("Huston (2020): spacer seed region") + guides(fill="none")

manfredonia_seed_plot + lan_seed_plot + 
  sun_invitro_seed_plot + sun_invivo_seed_plot +
  huston_seed_plot + plot_spacer() + plot_layout(ncol=2)
```

## Elastic net regression

```{r model_data}
window_start <- -5
window_stop <- 5

# set folds
set.seed(21)
num_folds <- 5
fold_ids <- sample(cut(seq(sum(nchar(guide_rate$spacer)==20)), breaks=num_folds, labels=F))

# sequence features
guide_sequence <- t(sapply(guide_rate$start,
                           function(x) {
                             tmp_positions <- (x+19+window_stop):(x+window_start)
                             # factor(ifelse(viral_genome$base[tmp_positions] %in% c("A", "T"),
                             #               "A_T", "C_G"),
                             #        levels=c("A_T", "C_G"))
                             # ifelse(viral_genome$base[tmp_positions] %in% c("A", "T"),
                             #        0, 1)
                             viral_genome$base[tmp_positions]
                           }))
guide_sequence <- data.frame(lapply(seq(ncol(guide_sequence)),
                                    function(x)  {
                                      factor(guide_sequence[, x], 
                                             levels=c("A", "C", "G", "U")) 
                                    }))
colnames(guide_sequence) <- paste0("seq_", (1+window_start):(20+window_stop))

# structure features
guide_structure <- t(sapply(guide_rate$start,
                            function(x) {
                              tmp_positions <- (x+19+window_stop):(x+window_start)
                              viral_genome$invivo[tmp_positions]
                            }))
guide_structure <- data.frame(lapply(seq(ncol(guide_structure)),
                                     function(x) {
                                       factor(guide_structure[, x],
                                              levels=c("structured", "unstructured"))
                                     }))
colnames(guide_structure) <- paste0("str_", (1+window_start):(20+window_stop))

# data for model
regression_data <- data.frame(rate=guide_rate$Estimate, guide_sequence, guide_structure)
regression_data <- subset(regression_data, nchar(guide_rate$spacer)==20)
regression_data_onehot <- as.matrix(mltools::one_hot(data.table::data.table(regression_data)))
regression_data_onehot <- subset(regression_data_onehot,
                                 select=!grepl("_structured", colnames(regression_data_onehot)))
```

Model 1: sequence + structure

* sequence: spacer sequence +/- 5 nt
* viral structure: spacer sequence +/- 5 nt

```{r model_1, warning=F, fig.height=8}
# optimize hyperparameters
model1 <- list(r2=optimize_glmnet_hyperparameters(regression_data_onehot,
                                                  fold_ids,
                                                  metric="r2"),
               MSE=optimize_glmnet_hyperparameters(regression_data_onehot,
                                                   fold_ids,
                                                   metric="mse"))
model1_hyperparameter_plot <- ((model1$r2$best_r2_plot + ggtitle(bquote("optimize"~r^2))) + 
                           (model1$MSE$best_r2_plot + ggtitle("optimize MSE"))) /
  (model1$r2$mse_plot + model1$MSE$mse_plot)
model1_optimize_plot <- ((model1$MSE$best_r2_plot + ggtitle("optimizing testing r^2")) / 
                           model1$MSE$best_r2_pearson_r_plot) | 
  ((model1$MSE$best_pearson_r_r2_plot + ggtitle("optimize testing pearson r")) /
     model1$MSE$best_pearson_r_plot)
model1_optimize_plot
# plot coefficients
model1_bestfit <- model1$MSE$all_models[[which(names(model1$MSE$all_models) == model1$MSE$best_alpha)]]
model1_coef_plot <- plot_coefs(model1_bestfit, model1$MSE$best_alpha, model1$MSE$best_lambda)
# plot fit across folds
model1_fold_plot <- plot_fold_fits(regression_data_onehot, fold_ids, 
                                   model1$MSE$best_alpha, model1$MSE$best_lambda)

model1_plot <- ((model1$MSE$mse_plot + 
                   ggtitle("Model 1", subtitle="rate ~ sequence + structure (+/- 5nt)")) +
                  (model1$MSE$best_r2_plot) +
                  (model1$MSE$best_pearson_r_plot)) / 
  (model1_coef_plot + ggtitle("", subtitle="") + 
                     labs(col="sequence", shape="structure")) /
  model1_fold_plot
model1_plot
```

```{r model1_randomforest, fig.height=8}
model1_rf_regression <- randomForest(x=regression_data_onehot[, -1],
                                     y=regression_data_onehot[, 1],
                                     importance=T)
model1_rf_regression_importance <- data.frame(model1_rf_regression$importance, 
                                              matrix(unlist(strsplit(rownames(model1_rf_regression$importance), 
                                                                     split="_")), 
                                                     ncol=3, byrow=T))
colnames(model1_rf_regression_importance) <- c("increaseMSE", "increaseNodePurity",
                                               "type", "position", "coef")
model1_rf_regression_importance$position <- with(model1_rf_regression_importance,
                                                 as.numeric(sub("\\.", "-", position)))
model1_rf_regression_r2 <- 1-sum((regression_data_onehot[,1]-model1_rf_regression$predicted)^2) / 
  sum((regression_data_onehot[,1]-mean(regression_data_onehot[,1]))^2)
model1_rf_regression_plot <- (ggplot(model1_rf_regression_importance) + 
    geom_point(data=subset(model1_rf_regression_importance, type=="seq"), 
               aes(x=position, y=increaseMSE, col=coef), alpha=0.5) +
    geom_point(data=subset(model1_rf_regression_importance, type=="str"),
               aes(x=position, y=increaseMSE, shape=coef), alpha=0.75) +
    annotate("rect", xmin=0.5, xmax=20.5, fill="grey", alpha=0.2, 
             ymin=min(model1_rf_regression_importance$increaseMSE) - 1, 
             ymax=max(model1_rf_regression_importance$increaseMSE) + 1) + 
    annotate("text", x=0.5, y=max(model1_rf_regression_importance$increaseMSE) + 1, 
             label="spacer,  5' : 3'", 
             col="red", hjust="inward", vjust="inward") + 
    xlab("position") + ylab("mean decrease in accuracy") + theme_bw() +
  ggtitle("Model 1: random forest (regression)", 
          subtitle=bquote(r^2~"="~.(round(model1_rf_regression_r2, digits=3))))) + 
  (ggplot(data.frame(true=regression_data_onehot[,1], 
                     predicted=model1_rf_regression$predicted), 
          aes(x=true, y=predicted)) + 
     geom_point() + geom_abline(slope=1, intercept=0) + theme_bw() + 
     xlab("true rate (RFU/min)") + ylab("predicted rate (RFU/min)"))

model1_rf_classification <- randomForest(x=regression_data_onehot[, -1],
                                         y=factor(ifelse(regression_data_onehot[, 1]>20,
                                                         "rate>20", "rate<20")),
                                         importance=T)
model1_rf_classification_importance <- data.frame(model1_rf_classification$importance, 
                                                  matrix(unlist(strsplit(rownames(model1_rf_classification$importance), 
                                                                         split="_")), 
                                                         ncol=3, byrow=T))
colnames(model1_rf_classification_importance) <- c("bad", "good",
                                                   "MeanDecreaseAccuracy", "MeanDecreaseGini",
                                                   "type", "position", "coef")
model1_rf_classification_importance$position <- with(model1_rf_classification_importance,
                                                     as.numeric(sub("\\.", "-", position)))
model1_rf_classification_accuracy <- mean(model1_rf_classification$predicted == 
                                        factor(ifelse(regression_data_onehot[, 1]>20, "rate>20", "rate<20")))
model1_rf_classification_plot <- (ggplot(model1_rf_classification_importance) + 
    geom_point(data=subset(model1_rf_classification_importance, type=="seq"), 
               aes(x=position, y=MeanDecreaseAccuracy, col=coef), alpha=0.5) +
    geom_point(data=subset(model1_rf_classification_importance, type=="str"),
               aes(x=position, y=MeanDecreaseAccuracy, shape=coef), alpha=0.75) +
    annotate("rect", xmin=0.5, xmax=20.5, fill="grey", alpha=0.2, 
             ymin=min(model1_rf_classification_importance$MeanDecreaseAccuracy) - 
               sd(model1_rf_classification_importance$MeanDecreaseAccuracy), 
             ymax=max(model1_rf_classification_importance$MeanDecreaseAccuracy) + 
               sd(model1_rf_classification_importance$MeanDecreaseAccuracy)) + 
    annotate("text", x=0.5, y=max(model1_rf_classification_importance$MeanDecreaseAccuracy) + 
               sd(model1_rf_classification_importance$MeanDecreaseAccuracy), 
             label="spacer,  5' : 3'", 
             col="red", hjust="inward", vjust="inward") + 
    xlab("position") + ylab("mean decrease in accuracy") + theme_bw() +
  ggtitle("Model 1: random forest (classification: rate > 20)", 
          subtitle=bquote("accuracy ="~.(round(model1_rf_classification_accuracy, digits=3))))) + 
  (ggplot(data.frame(true=factor(ifelse(regression_data_onehot[, 1]>20,"rate>20", "rate<20")), 
                     predicted=model1_rf_classification$predicted), 
          aes(x=true, y=predicted)) + 
     geom_count() + theme_bw() + 
     xlab("true rate > 20 RFU/min") + ylab("predicted rate > 20 RFU/min"))

model1_rf_regression_plot / model1_rf_classification_plot
```

Model 2: only sequence

* sequence: spacer sequence +/- 5 nt

```{r model_2, warning=F, fig.height=8, eval=F}
model2_data <- c("rate", grep("seq", colnames(regression_data_onehot), value=T))
model2_data <- regression_data_onehot[, model2_data]
# optimize hyperparameters
model2 <- list(r2=optimize_glmnet_hyperparameters(model2_data,
                                                  fold_ids,
                                                  metric="r2"),
               MSE=optimize_glmnet_hyperparameters(model2_data,
                                                   fold_ids,
                                                   metric="mse"))
model2_hyperparameter_plot <- ((model2$r2$best_r2_plot + ggtitle(bquote("optimize"~r^2))) + 
                           (model2$MSE$best_r2_plot + ggtitle("optimize MSE"))) /
  (model2$r2$mse_plot + model2$MSE$mse_plot)
model2_optimize_plot <- ((model2$MSE$best_r2_plot + ggtitle("optimizing testing r^2")) /
                           model2$MSE$best_r2_pearson_r_plot) | 
  ((model2$MSE$best_pearson_r_r2_plot + ggtitle("optimize testing pearson r")) /
     model2$MSE$best_pearson_r_plot)
model2_optimize_plot
# plot coefficients
model2_bestfit <- model2$MSE$all_models[[which(names(model2$MSE$all_models) == model2$MSE$best_alpha)]]
model2_coef_plot <- plot_coefs(model2_bestfit, model2$MSE$best_alpha, model2$MSE$best_lambda)
# plot fit across folds
model2_fold_plot <- plot_fold_fits(regression_data_onehot, fold_ids, 
                                   model2$MSE$best_alpha, model2$MSE$best_lambda)

model2_plot <- ((model2$MSE$mse_plot + 
                   ggtitle("Model 2", subtitle="rate ~ sequence (+/- 5nt)")) +
                  (model2$MSE$best_r2_plot) +
                  (model2$MSE$best_pearson_r_plot)) / 
  (model2_coef_plot + ggtitle("", subtitle="") + 
                     labs(col="sequence", shape="structure")) /
  model2_fold_plot
model2_plot
```

Model 3: only structure

* viral structure: spacer sequence +/- 5 nt

```{r model_3, warning=F, fig.height=8, eval=F}
model3_data <- c("rate", grep("str", colnames(regression_data_onehot), value=T))
model3_data <- regression_data_onehot[, model3_data]
# optimize hyperparameters
model3 <- list(r2=optimize_glmnet_hyperparameters(model3_data,
                                                  fold_ids,
                                                  metric="r2"),
               MSE=optimize_glmnet_hyperparameters(model3_data,
                                                   fold_ids,
                                                   metric="mse"))
model3_hyperparameter_plot <- ((model3$r2$best_r2_plot + ggtitle(bquote("optimize"~r^2))) + 
                           (model3$MSE$best_r2_plot + ggtitle("optimize MSE"))) /
  (model3$r2$mse_plot + model3$MSE$mse_plot)
model3_optimize_plot <- ((model3$MSE$best_r2_plot + ggtitle("optimizing testing r^2")) /
                           model3$MSE$best_r2_pearson_r_plot) | 
  ((model3$MSE$best_pearson_r_r2_plot + ggtitle("optimize testing pearson r")) /
     model3$MSE$best_pearson_r_plot)
model3_optimize_plot
# plot coefficients
model3_bestfit <- model3$MSE$all_models[[which(names(model3$MSE$all_models) == model3$MSE$best_alpha)]]
model3_coef_plot <- plot_coefs(model3_bestfit, model3$MSE$best_alpha, model3$MSE$best_lambda)
# plot fit across folds
model3_fold_plot <- plot_fold_fits(regression_data_onehot, fold_ids, 
                                   model3$MSE$best_alpha, model3$MSE$best_lambda)

model3_plot <- ((model3$MSE$mse_plot + 
                   ggtitle("Model 3", subtitle="rate ~ structure (+/- 5nt)")) +
                  (model3$MSE$best_r2_plot) +
                  (model3$MSE$best_pearson_r_plot)) / 
  (model3_coef_plot + ggtitle("", subtitle="") + 
                     labs(col="sequence", shape="structure")) /
  model3_fold_plot
model3_plot
```

Model 4: only sequence (binary)

* sequence: spacer sequence (A/T: 0 ; C/G: 1) +/- 5 nt

```{r model_4, warning=F, fig.height=8}
model4_data <- c(grep("seq", colnames(regression_data), value=T))
model4_data <- regression_data[, model4_data]
model4_data <- data.frame(lapply(seq(ncol(model4_data)),
                                 function(x) {
                                   tmp_seq <- as.character(model4_data[, x])
                                   tmp_seq[tmp_seq %in% c("A", "U")] <- "A/U"
                                   tmp_seq[tmp_seq %in% c("C", "G")] <- "C/G"
                                   tmp_seq <- factor(tmp_seq, levels=c("A/U", "C/G"))
                                   return(tmp_seq)
                                 }))
colnames(model4_data) <- c(grep("seq", colnames(regression_data), value=T))
model4_data <- data.frame(rate = regression_data$rate, model4_data)
model4_data_onehot <- as.matrix(mltools::one_hot(data.table::data.table(model4_data)))
model4_data_onehot <- subset(model4_data_onehot,
                             select=!grepl("A/U", colnames(model4_data_onehot)))
# optimize hyperparameters
model4 <- list(r2=optimize_glmnet_hyperparameters(model4_data_onehot,
                                                  fold_ids,
                                                  metric="r2"),
               MSE=optimize_glmnet_hyperparameters(model4_data_onehot,
                                                   fold_ids,
                                                   metric="mse"))
model4_hyperparameter_plot <- ((model4$r2$best_r2_plot + ggtitle(bquote("optimize"~r^2))) + 
                           (model4$MSE$best_r2_plot + ggtitle("optimize MSE"))) /
  (model4$r2$mse_plot + model4$MSE$mse_plot)
model4_optimize_plot <- ((model4$MSE$best_r2_plot + ggtitle("optimizing testing r^2")) /
                           model4$MSE$best_r2_pearson_r_plot) |
  ((model4$MSE$best_pearson_r_r2_plot + ggtitle("optimize testing pearson r")) /
     model4$MSE$best_pearson_r_plot)
model4_optimize_plot
# plot coefficients
model4_bestfit <- model4$MSE$all_models[[which(names(model4$MSE$all_models) == model4$MSE$best_alpha)]]
model4_coef_plot <- plot_coefs(model4_bestfit, model4$MSE$best_alpha, model4$MSE$best_lambda)
# plot fit across folds
model4_fold_plot <- plot_fold_fits(regression_data_onehot, fold_ids, 
                                   model4$MSE$best_alpha, model4$MSE$best_lambda)

model4_plot <- ((model4$MSE$mse_plot + 
                   ggtitle("Model 4", subtitle="rate ~ sequence [A/U v. C/G] (+/- 5nt)")) +
                  (model4$MSE$best_r2_plot) +
                  (model4$MSE$best_pearson_r_plot)) / 
  (model4_coef_plot + ggtitle("", subtitle="") + 
                     labs(col="sequence", shape="structure")) /
  model4_fold_plot
model4_plot
```

Model 5: sequence (binary) + structure

* sequence: spacer sequence (A/T: 0 ; C/G: 1) +/- 5 nt
* viral structure: spacer sequence +/- 5 nt

```{r model_5, warning=F, fig.height=8}
model5_data <- data.frame(model4_data,
                          regression_data[, grepl("str", colnames(regression_data))])
model5_data_onehot <- as.matrix(mltools::one_hot(data.table::data.table(model5_data)))
model5_data_onehot <- subset(model5_data_onehot,
                             select=!grepl("A/T", colnames(model5_data_onehot)) &
                               !grepl("_structured", colnames(model5_data_onehot)))
# optimize hyperparameters
model5 <- list(r2=optimize_glmnet_hyperparameters(model5_data_onehot,
                                                  fold_ids,
                                                  metric="r2"),
               MSE=optimize_glmnet_hyperparameters(model5_data_onehot,
                                                   fold_ids,
                                                   metric="mse"))
model5_hyperparameter_plot <- ((model5$r2$best_r2_plot + ggtitle(bquote("optimize"~r^2))) + 
                           (model5$MSE$best_r2_plot + ggtitle("optimize MSE"))) /
  (model5$r2$mse_plot + model5$MSE$mse_plot)
model5_optimize_plot <- ((model5$MSE$best_r2_plot + ggtitle("optimizing testing r^2")) /
                           model5$MSE$best_r2_pearson_r_plot) | 
  ((model5$MSE$best_pearson_r_r2_plot + ggtitle("optimize testing pearson r")) /
     model5$MSE$best_pearson_r_plot)
model5_optimize_plot
# plot coefficients
model5_bestfit <- model5$MSE$all_models[[which(names(model5$MSE$all_models) == model5$MSE$best_alpha)]]
model5_coef_plot <- plot_coefs(model5_bestfit, model5$MSE$best_alpha, model5$MSE$best_lambda)
# plot fit across folds
model5_fold_plot <- plot_fold_fits(regression_data_onehot, fold_ids, 
                                   model5$MSE$best_alpha, model5$MSE$best_lambda)

model5_plot <- ((model5$MSE$mse_plot + 
                   ggtitle("Model 5", subtitle="rate ~ sequence [A/U v. C/G] + structure(+/- 5nt)")) +
                  (model5$MSE$best_r2_plot) +
                  (model5$MSE$best_pearson_r_plot)) / 
  (model5_coef_plot + ggtitle("", subtitle="") + 
                     labs(col="sequence", shape="structure")) /
  model5_fold_plot
model5_plot
```

```{r verify_coefs}
pos.3_plot <- ggplot_violin(regression_data, x_var="seq_.3", y_var="rate") + 
  ggtitle("position -4 to spacer") + xlab("viral genome") +
  geom_text(data=aggregate(rate ~ seq_.3, data=regression_data, FUN=length),
            aes(x=seq_.3, y=80, label=paste("n =", rate))) + 
  annotate(geom="text", x="C", y=90, col="red",
           label=paste("p =", signif(wilcox.test(rate ~ (seq_.3 == "C"), 
                                                 data=regression_data)$p.value, 
                                     digits=3)))

pos0_plot <- ggplot_violin(regression_data, x_var="seq_0", y_var="rate") + 
  ggtitle("position -1 to spacer") + xlab("viral genome") +
  geom_text(data=aggregate(rate ~ seq_0, data=regression_data, FUN=length),
            aes(x=seq_0, y=80, label=paste("n =", rate))) + 
  annotate(geom="text", x="G", y=90, col="red",
           label=paste("p =", signif(wilcox.test(rate ~ (seq_0 == "G"), 
                                                 data=regression_data)$p.value, 
                                     digits=3)))

pos3_plot <- ggplot_violin(regression_data, x_var="seq_3", y_var="rate") + 
  ggtitle("position 3 in spacer") + xlab("viral genome") +
  geom_text(data=aggregate(rate ~ seq_3, data=regression_data, FUN=length),
            aes(x=seq_3, y=80, label=paste("n =", rate))) + 
  annotate(geom="text", x="T", y=90, col="red",
           label=paste("p =", signif(wilcox.test(rate ~ (seq_3 == "U"), 
                                                 data=regression_data)$p.value, 
                                     digits=3)))

pos8_plot <- ggplot_violin(regression_data, x_var="seq_8", y_var="rate") + 
  ggtitle("position 8 in spacer") + xlab("viral genome") +
  geom_text(data=aggregate(rate ~ seq_8, data=regression_data, FUN=length),
            aes(x=seq_8, y=80, label=paste("n =", rate))) + 
  annotate(geom="text", x="A", y=90, col="red",
           label=paste("p =", signif(wilcox.test(rate ~ (seq_8 == "A"), 
                                                 data=regression_data)$p.value, 
                                     digits=3)))

pos22_plot <- ggplot_violin(regression_data, x_var="seq_22", y_var="rate") + 
  ggtitle("position +2 to spacer") + xlab("viral genome") +
  geom_text(data=aggregate(rate ~ seq_22, data=regression_data, FUN=length),
            aes(x=seq_22, y=80, label=paste("n =", rate))) + 
  annotate(geom="text", x="G", y=90, col="red",
           label=paste("p =", signif(wilcox.test(rate ~ (seq_22 == "G"), 
                                                 data=regression_data)$p.value, 
                                     digits=3)))

pos25_plot <- ggplot_violin(regression_data, x_var="seq_25", y_var="rate") + 
  ggtitle("position +5 to spacer") + xlab("viral genome") +
  geom_text(data=aggregate(rate ~ seq_25, data=regression_data, FUN=length),
            aes(x=seq_25, y=80, label=paste("n =", rate))) + 
  annotate(geom="text", x="A", y=90, col="red",
           label=paste("p =", signif(wilcox.test(rate ~ (seq_25 == "A"), 
                                                 data=regression_data)$p.value, 
                                     digits=3)))

model1_coef_plot / 
  ((pos.3_plot + guides(fill="none")) | 
     (pos0_plot + guides(fill="none")) | 
     (pos3_plot + labs(fill="base"))) / 
  ((pos8_plot + guides(fill="none")) | 
     (pos22_plot + guides(fill="none")) | 
     (pos25_plot + labs(fill="base")))

# subset(guide_rate, nchar(spacer) == 20)[with(regression_data, which(seq_0 == "G" & rate > 20)),]
```

Model 6: rate ~ (antitag position 1) * (spacer structure) + (downstream unstructured U)

* antitag position 1 
* spacer structure
* downstream unstructured U

```{r model6, warning=F, fig.height=8}
model6_data <- subset(guide_rate,
                      nchar(spacer)==20,
                      select=c("Estimate", "antitag_pos1", 
                               "downstream_unstructured_U", 
                               "spacer_structure"))
model6_data$antitag_pos1 <- factor(model6_data$antitag_pos1)
model6_data_onehot <- mltools::one_hot(data.table::data.table(model6_data))
# compute model across folds
model6_fits <- lapply(seq(length(unique(fold_ids))),
                      function(x) {
                        tmp_training <- subset(model6_data_onehot, fold_ids != x)
                        tmp_testing <- subset(model6_data_onehot, fold_ids == x)
                        tmp_fit <- lm(Estimate ~ antitag_pos1_A + antitag_pos1_C +
                                        antitag_pos1_G*spacer_structure + antitag_pos1_U +
                                        downstream_unstructured_U, data=tmp_training)
                        # tmp_training <- subset(model6_data, fold_ids != x)
                        # tmp_testing <- subset(model6_data, fold_ids == x)
                        # tmp_fit <- lm(Estimate ~ antitag_pos1*spacer_structure + 
                        #                 downstream_unstructured_U,
                        #               data=tmp_training)
                        tmp_training$predicted <- predict(tmp_fit, 
                                                          newdata=tmp_training)
                        tmp_testing$predicted <- predict(tmp_fit,
                                                         newdata=tmp_testing)
                        tmp_testing_r2 <- 1 - with(tmp_testing, sum((Estimate - predicted)^2)) / 
                          with(tmp_testing, sum((Estimate - mean(Estimate))^2))
                        tmp_training_cor <- with(tmp_training, cor(predicted, Estimate))
                        tmp_testing_cor <- with(tmp_training, cor(predicted, Estimate))
                        tmp_stats <- data.frame(split=c("training", "testing"),
                                                r2=c(summary(tmp_fit)$r.squared,
                                                     tmp_testing_r2),
                                                pearson_r=c(tmp_training_cor,
                                                            tmp_testing_cor),
                                                fold_id=x)
                        tmp_plot_data <- rbind(data.frame(tmp_training, split="training"), 
                                               data.frame(tmp_testing, split="testing"))
                        tmp_plot <- ggplot(tmp_plot_data, aes(x=Estimate, y=predicted, col=split)) + 
                          geom_point() + geom_abline(slope=1, intercept=0) + theme_bw() + 
                          scale_color_manual(values=c("#E69F00", "#56B4E9")) + 
                          ggtitle(paste("fold:", x)) + 
                          xlab("true rate (RFU/min)") + ylab("predicted rate (RFU/min)") + 
                          annotate(geom="text", x=Inf, y=-Inf, col=ucb_colors$Lawrence,
                                    label=bquote(r^2~"="~.(round(tmp_stats$r2[1], digits=3))),
                                    hjust="inward", vjust=-2) + 
                           annotate(geom="text", x=Inf, y=-Inf, col=ucb_colors$`California Gold`,
                                    label=bquote(r^2~"="~.(round(tmp_stats$r2[2], digits=3))),
                                    hjust="inward", vjust=-1) + 
                           annotate(geom="text", x=Inf, y=Inf, col="black", label="y=x",
                                    hjust="inward", vjust="inward") + 
                           annotate(geom="text", x=-Inf, y=Inf, col=ucb_colors$Lawrence,
                                    label=bquote(rho~"="~.(round(tmp_stats$pearson_r[1], digits=2))),
                                    hjust="inward", vjust=1.5) +
                           annotate(geom="text", x=-Inf, y=Inf, col=ucb_colors$`California Gold`,
                                    label=bquote(rho~"="~.(round(tmp_stats$pearson_r[2], digits=2))),
                                    hjust="inward", vjust=2.5)
                        return(list(fit=tmp_fit, stats=tmp_stats, plot=tmp_plot))
                      })
model6_stats <- do.call(rbind, lapply(model6_fits, function(x) x$stats))
model6_r2 <- aggregate(r2 ~ split, data=model6_stats, FUN=mean)
model6_pearson_r <- aggregate(pearson_r ~ split, data=model6_stats, FUN=mean)
model6_fold_plot <- wrap_plots(lapply(model6_fits, 
                                      function(x) x$plot + guides(col="none")), nrow=1)
model6_all_coef <- do.call(rbind, 
                           lapply(seq_along(model6_fits),
                                  function(x) {
                                    tmp_coef <- summary(model6_fits[[x]]$fit)$coefficients
                                    data.frame(tmp_coef,
                                               fold_id=x,
                                               coef=rownames(tmp_coef))
                                  }))
model6_all_coef$significant <- model6_all_coef$Pr...t.. < 0.05
model6_coef_plot <- ggplot(model6_all_coef, 
                           aes(x=coef, y=Estimate, col=significant)) + 
  geom_point(alpha=0.5) + theme_bw() + xlab("") + ylab(expr(beta)) + 
  theme(axis.text.x=element_text(angle=45, hjust=1)) + labs(col="p < 0.05") + 
  #scale_color_manual(values=c("black", "red"))
  scale_color_manual(values=c(ucb_colors$`Berkeley Blue`, ucb_colors$`California Gold`))

model6_coef_plot / model6_fold_plot
```

```{r model6_comparisons}
model6_comparison_data <- subset(guide_rate,
                                 select=c("Estimate", "antitag_pos1", 
                                          "downstream_unstructured_U", "spacer_structure",
                                          "spacer"))
model6_comparison_data$antitag_pos1 <- factor(model6_comparison_data$antitag_pos1)
model6_comparison_data_onehot <- mltools::one_hot(data.table::data.table(model6_comparison_data))

summary(glm(Estimate ~ ., 
           data=subset(model6_comparison_data_onehot, 
                       nchar(spacer)==20, 
                       select=-spacer),
           family="gaussian"))
summary(glm(Estimate ~ ., 
           data=subset(model6_comparison_data_onehot, 
                       select=-spacer),
           family="gaussian"))

(ggplot(guide_rate, aes(x=Estimate)) + geom_histogram(binwidth=5) + 
    geom_vline(xintercept=20, col="red") + theme_bw() + 
    xlab("rate (RFU/min)") + ylab("")) + 
  all_plots[[guide_rate$guide_id[sample(which(guide_rate$Estimate > 20), size=1)]]] +
  all_plots[[guide_rate$guide_id[sample(which(guide_rate$Estimate < 20), size=1)]]]

summary(glm((Estimate > 20) ~ ., 
           data=subset(model6_comparison_data_onehot, 
                       nchar(spacer)==20, 
                       select=-spacer),
           family="binomial"))
summary(glm((Estimate > 20) ~ ., 
           data=subset(model6_comparison_data_onehot, 
                       select=-spacer),
           family="binomial"))
```

Model 7: reduced features

* antitag position 1 
* downstream unstructured U
* spacer structure

```{r model7, warning=F, fig.height=8}
model7_data <- subset(guide_rate,
                      nchar(spacer)==20,
                      select=c("Estimate", "antitag_pos1"))
model7_data$antitag_pos1 <- factor(model7_data$antitag_pos1)
model7_data_onehot <- mltools::one_hot(data.table::data.table(model7_data))
# compute model across folds
model7_fits <- lapply(seq(length(unique(fold_ids))),
                      function(x) {
                        tmp_training <- subset(model7_data_onehot, fold_ids != x)
                        tmp_testing <- subset(model7_data_onehot, fold_ids == x)
                        tmp_fit <- lm(Estimate ~ ., data=tmp_training)
                        tmp_training$predicted <- predict(tmp_fit, 
                                                          newdata=tmp_training)
                        tmp_testing$predicted <- predict(tmp_fit,
                                                         newdata=tmp_testing)
                        tmp_testing_r2 <- 1 - with(tmp_testing, sum((Estimate - predicted)^2)) / 
                          with(tmp_testing, sum((Estimate - mean(Estimate))^2))
                        tmp_training_cor <- with(tmp_training, cor(predicted, Estimate))
                        tmp_testing_cor <- with(tmp_training, cor(predicted, Estimate))
                        tmp_stats <- data.frame(split=c("training", "testing"),
                                                r2=c(summary(tmp_fit)$r.squared,
                                                     tmp_testing_r2),
                                                pearson_r=c(tmp_training_cor,
                                                            tmp_testing_cor),
                                                fold_id=x)
                        tmp_plot_data <- rbind(data.frame(tmp_training, split="training"), 
                                               data.frame(tmp_testing, split="testing"))
                        tmp_plot <- ggplot(tmp_plot_data, aes(x=Estimate, y=predicted, col=split)) + 
                          geom_point() + geom_abline(slope=1, intercept=0) + theme_bw() + 
                          scale_color_manual(values=c("#E69F00", "#56B4E9")) + 
                          ggtitle(paste("fold:", x)) + 
                          xlab("true rate (RFU/min)") + ylab("predicted rate (RFU/min)") + 
                          annotate(geom="text", x=Inf, y=-Inf, col=ucb_colors$Lawrence,
                                    label=bquote(r^2~"="~.(round(tmp_stats$r2[1], digits=3))),
                                    hjust="inward", vjust=-2) + 
                           annotate(geom="text", x=Inf, y=-Inf, col=ucb_colors$`California Gold`,
                                    label=bquote(r^2~"="~.(round(tmp_stats$r2[2], digits=3))),
                                    hjust="inward", vjust=-1) + 
                           annotate(geom="text", x=Inf, y=Inf, col="black", label="y=x",
                                    hjust="inward", vjust="inward") + 
                           annotate(geom="text", x=-Inf, y=Inf, col=ucb_colors$Lawrence,
                                    label=bquote(rho~"="~.(round(tmp_stats$pearson_r[1], digits=2))),
                                    hjust="inward", vjust=1.5) +
                           annotate(geom="text", x=-Inf, y=Inf, col=ucb_colors$`California Gold`,
                                    label=bquote(rho~"="~.(round(tmp_stats$pearson_r[2], digits=2))),
                                    hjust="inward", vjust=2.5)
                        return(list(fit=tmp_fit, stats=tmp_stats, plot=tmp_plot))
                      })
model7_stats <- do.call(rbind, lapply(model7_fits, function(x) x$stats))
model7_r2 <- aggregate(r2 ~ split, data=model7_stats, FUN=mean)
model7_pearson_r <- aggregate(pearson_r ~ split, data=model7_stats, FUN=mean)
model7_fold_plot <- wrap_plots(lapply(model7_fits, 
                                      function(x) x$plot + guides(col="none")), nrow=1)
model7_all_coef <- do.call(rbind, 
                           lapply(seq_along(model7_fits),
                                  function(x) {
                                    tmp_coef <- summary(model7_fits[[x]]$fit)$coefficients
                                    data.frame(tmp_coef,
                                               fold_id=x,
                                               coef=rownames(tmp_coef))
                                  }))
model7_all_coef$significant <- model7_all_coef$Pr...t.. < 0.05
model7_coef_plot <- ggplot(model7_all_coef, 
                           aes(x=coef, y=Estimate, col=significant)) + 
  geom_point(alpha=0.5) + theme_bw() + xlab("") + ylab(expr(beta)) + 
  theme(axis.text.x=element_text(angle=45, hjust=1)) + labs(col="p < 0.05") + 
  #scale_color_manual(values=c("black", "red"))
  scale_color_manual(values=c(ucb_colors$`Berkeley Blue`, ucb_colors$`California Gold`))

model7_coef_plot / model7_fold_plot
```

Model 8: model cis cleavage site

* anti-tag
* target 
* cis cleavage site

```{r model8, warning=F, fig.height=8}
model8_data <- lapply(which(nchar(guide_rate$spacer)==20),
                      function(x) {
                        tmp_seq <- with(guide_rate[x,],
                                        c(cis_cleavage_site, target, antitag))
                        rev(unlist(strsplit(tmp_seq, split="")))
                      })
model8_data <- data.frame(do.call(rbind, model8_data))
model8_data <- data.frame(lapply(seq(ncol(model8_data)),
                                 function(x)  {
                                   factor(model8_data[, x], 
                                          levels=c("A", "C", "G", "U")) 
                                 }))
colnames(model8_data) <- c(paste0("seq_", seq(-3, 20)),
                           paste0("seq_", seq(21 + cis_cleavage_start - cis_cleavage_window/2,
                                              21 + cis_cleavage_start + cis_cleavage_window/2 - 1)))
model8_data <- data.frame(Estimate=subset(guide_rate, nchar(spacer)==20)$Estimate,
                          model8_data)
model8_data_onehot <- as.matrix(mltools::one_hot(data.table::data.table(model8_data)))

# optimize hyperparameters
model8 <- list(r2=optimize_glmnet_hyperparameters(model8_data_onehot,
                                                  fold_ids,
                                                  metric="r2"),
               MSE=optimize_glmnet_hyperparameters(model8_data_onehot,
                                                   fold_ids,
                                                   metric="mse"))
model8_hyperparameter_plot <- ((model8$r2$best_r2_plot + ggtitle(bquote("optimize"~r^2))) + 
                           (model8$MSE$best_r2_plot + ggtitle("optimize MSE"))) /
  (model8$r2$mse_plot + model8$MSE$mse_plot)
model8_optimize_plot <- ((model8$MSE$best_r2_plot + ggtitle("optimizing testing r^2")) /
                           model8$MSE$best_r2_pearson_r_plot) | 
  ((model8$MSE$best_pearson_r_r2_plot + ggtitle("optimize testing pearson r")) /
     model8$MSE$best_pearson_r_plot)
model8_optimize_plot
# plot coefficients
model8_bestfit <- model8$MSE$all_models[[which(names(model8$MSE$all_models) == model8$MSE$best_alpha)]]
model8_coef_plot <- plot_coefs(model8_bestfit, model8$MSE$best_alpha, model8$MSE$best_lambda)
# plot fit across folds
model8_fold_plot <- plot_fold_fits(regression_data_onehot, fold_ids, 
                                   model8$MSE$best_alpha, model8$MSE$best_lambda)

model8_plot <- ((model8$MSE$mse_plot + 
                   ggtitle("Model 2", subtitle="rate ~ sequence (+/- 5nt)")) +
                  (model8$MSE$best_r2_plot) +
                  (model8$MSE$best_pearson_r_plot)) / 
  (model8_coef_plot + ggtitle("", subtitle="") + 
                     labs(col="sequence", shape="structure")) /
  model8_fold_plot
model8_plot
```

## Sequence logo

```{r sequence_logo}
allSpacers_freq <- compute_nt_freq(subset(guide_rate$spacer,
                                          nchar(guide_rate$spacer)==20))
nt_freq <- sapply(c("A", "U", "C", "G"),
                  function(x) mean(unlist(strsplit(subset(guide_rate$spacer,
                                                          nchar(guide_rate$spacer)==20), 
                                                   split=""))==x))

num_spacers <- 50

topSpacers_freq <- compute_nt_freq(subset(guide_rate$spacer,
                                          nchar(guide_rate$spacer) == 20 &
                                            rank(-guide_rate$Estimate) <= num_spacers))
topSpacers_info <- calculate_relative_info(topSpacers_freq, allSpacers_freq)

bottomSpacers_freq <- compute_nt_freq(subset(guide_rate$spacer,
                                             nchar(guide_rate$spacer) == 20 &
                                               rank(guide_rate$Estimate) <= num_spacers))
bottomSpacers_info <- calculate_relative_info(bottomSpacers_freq, allSpacers_freq)

(ggseqlogo(topSpacers_info, method="custom") + 
  ggtitle(paste("Sequence logo for top", num_spacers, "spacers")) + 
    ylim(0, 0.5)) / 
  (ggseqlogo(bottomSpacers_info, method="custom") +
     ggtitle(paste("Sequence logo for bottom", num_spacers, "spacers")) + 
     ylim(0, 0.5))

(ggseqlogo(calculate_shannon_entropy(allSpacers_freq), method="custom") + 
    ggtitle("Sequence logo for all 20nt spacers") + ylim(0, 2)) / 
  (ggseqlogo(calculate_shannon_entropy(topSpacers_freq), method="custom") + 
     ggtitle(paste("Top", num_spacers, "spacers")) + ylim(0, 2)) / 
  (ggseqlogo(calculate_shannon_entropy(bottomSpacers_freq), method="custom") + 
     ggtitle(paste("Bottom", num_spacers, "spacers")) + ylim(0, 2))
```

Top guides:

* G in position 19
* U's in positions 7-9, 11-14

Bottom guides:

* C's and G's in positions 9-12, 14-15

## Comparison to screening performed in gBlocks

```{r load_gblock_data}
# load round 1 data
gblock_round1_data <- xlsx::read.xlsx(file.path(project_dir,
                                                "NCR_Guide_Data.xlsx"),
                                      sheetName="Data",
                                      rowIndex=1:112)
gblock_round1_data <- subset(gblock_round1_data,
                             NCR.ID %in% guide_rate$NCR.id)
gblock_round1_data$X100.fM.Activator.above.noActivator <- with(gblock_round1_data,
                                                               as.numeric(X100.fM.Activator.Rate) -
                                                                 as.numeric(No.Activator.Rate))

# load round 2, plate 1-2 platemap
gblock_round2_platemap_1_2 <- xlsx::read.xlsx(file.path(project_dir, 
                                                        "Plate1_2_gBlock_384w_replicate_platemap.xlsx"),
                                              sheetIndex=1)
gblock_round2_platemap_1_2 <- subset(gblock_round2_platemap_1_2,
                                     subset=value_type %in% LETTERS[1:16])[, -1]
gblock_round2_platemap_1_2_activator <- data.frame(matrix("_noActivator", 
                                                nrow=nrow(gblock_round2_platemap_1_2),
                                                ncol=ncol(gblock_round2_platemap_1_2)))
gblock_round2_platemap_1_2_activator[, 13:24] <- "_100fM"
gblock_round2_platemap_1_2_activator[c(2, 4, 6), 9] <- "_100fM"
gblock_round2_platemap_1_2_activator[c(2, 4, 6), 11] <- "_100fM"
gblock_round2_platemap_1_2 <- data.frame(sample = paste0(unlist(gblock_round2_platemap_1_2),
                                                       unlist(gblock_round2_platemap_1_2_activator)),
                                         well_384 = paste0(rep(LETTERS[1:16], times=24),
                                                           rep(1:24, each=16)))
gblock_round2_platemap_1_2$sample <- sub(" ", "_", gblock_round2_platemap_1_2$sample)

# load round 2, plate 2-2 platemap
gblock_round2_platemap_2_2 <- xlsx::read.xlsx(file.path(project_dir, 
                                                        "Plate2_2_gBlock_384w_replicate_platemap.xlsx"),
                                              sheetIndex=1)
gblock_round2_platemap_2_2 <- subset(gblock_round2_platemap_2_2,
                                     subset=value_type %in% LETTERS[1:16])[, -1]
gblock_round2_platemap_2_2_activator <- data.frame(matrix("_noActivator", 
                                                nrow=nrow(gblock_round2_platemap_2_2),
                                                ncol=ncol(gblock_round2_platemap_2_2)))
gblock_round2_platemap_2_2_activator[, 13:24] <- "_100fM"
gblock_round2_platemap_2_2_activator[c(2, 4, 6), 9] <- "_100fM"
gblock_round2_platemap_2_2_activator[c(2, 4, 6), 11] <- "_100fM"
gblock_round2_platemap_2_2 <- data.frame(sample = paste0(unlist(gblock_round2_platemap_2_2),
                                                       unlist(gblock_round2_platemap_2_2_activator)),
                                         well_384 = paste0(rep(LETTERS[1:16], times=24),
                                                           rep(1:24, each=16)))
gblock_round2_platemap_2_2$sample <- sub(" ", "_", gblock_round2_platemap_2_2$sample)

# load round 2 data
gblock_data_dir <- file.path(project_dir, "100fM_gblock_data")
gblock_data_fnames <- list.files(gblock_data_dir)
gblock_data <- lapply(gblock_data_fnames,
                      function(x) {
                        tmp_plate <- sub("_100fM_Plate", "",
                                         sub("-", "_",
                                             sub(".xlsx", "", x)))
                        row_indices <- 55:115
                        tmp_data <- xlsx::read.xlsx(file.path(gblock_data_dir, x),
                                                    sheetIndex=1, rowIndex=row_indices, header=T)
                        tmp_data <- lapply(seq(nrow(tmp_data)),
                                           function(x) {
                                             data.frame(tmp_data[x, 1:3],
                                                        unlist(tmp_data[x, 4:387]),
                                                        colnames(tmp_data)[4:387],
                                                        row.names=NULL)
                                           })
                        tmp_data <- do.call(rbind, tmp_data)
                        colnames(tmp_data) <- c("cycle_number", "time", "temp", "signal", "well_384")
                        if(tmp_plate %in% paste0("gBlock", c("1_1", "2_1"))) {
                          well_96 <- mapping_384_to_96$well_96[match(tmp_data$well_384,
                                                                     mapping_384_to_96$well_384)]
                          tmp_platemap <- plate_maps[[sub("gBlock", "GS", tmp_plate)]]
                          tmp_data$sample <- tmp_platemap$sample[match(well_96,
                                                                       tmp_platemap$well_96)]
                        } else {
                          if(tmp_plate=="gBlock1_2") {
                            tmp_platemap <- gblock_round2_platemap_1_2
                          } else {
                            tmp_platemap <- gblock_round2_platemap_2_2
                          }
                          tmp_data$sample <- tmp_platemap$sample[match(tmp_data$well_384, tmp_platemap$well_384)]
                        }
                        tmp_data$plate <- tmp_plate
                        return(tmp_data)
                      })
gblock_data <- do.call(rbind, gblock_data)
gblock_data$sample[grepl("NA", gblock_data$sample)] <- "empty"
gblock_data$guide_id <- sapply(gblock_data$sample,
                               function(x) {
                                 ifelse(grepl("_", x),
                                        sub(" ", "_", sub("_.*", "", x)),
                                        "empty")
                               })
gblock_data$guide_id[gblock_data$guide_id=="612"] <- "612_Control"
gblock_data$guide_id[gblock_data$guide_id=="No"] <- "No_Protein"
gblock_data$activator <- factor(sapply(gblock_data$sample,
                                       function(x) {
                                         ifelse(grepl("_", x),
                                                sub(".*_", "", x),
                                                "empty")
                                       }), 
                                levels=c("100fM", "noActivator", "empty"))
gblock_data$cycle_number <- as.numeric(gblock_data$cycle_number)
gblock_data$signal <- as.numeric(gblock_data$signal)
gblock_data$time <- gblock_data$time/60 # convert from seconds to minutes
gblock_bkgd_empty <- mean(subset(gblock_data, sample=="empty")$signal, na.rm=T)
gblock_data$signal_bkgdSubtract <- gblock_data$signal - gblock_bkgd_empty
gblock_data <- subset(gblock_data, !(gblock_data$sample == "empty"))
gblock_data$activator <- droplevels(gblock_data$activator)
gblock_data <- subset(gblock_data, !is.na(signal))
```

```{r analyze_gblock_data}
# compute gblock rates
gblock_guide_ids <- unique(gblock_data$guide_id)
gblock_guide_ids <- gblock_guide_ids[!(gblock_guide_ids %in% c("612_Control", "No_Protein"))]
gblock_results <- lapply(gblock_guide_ids,
                         function(x) {
                           tmp <- try(analyze_guide(gblock_data, guide=x, time_start=30,
                                                    signal="signal_bkgdSubtract",
                                                    mixed_model=mixed),
                                      silent=T)
                           if(class(tmp) == "try-error") {
                             print(paste0("mixed model failed: NCR_", x))
                             tmp <- analyze_guide(gblock_data, guide=x, time_start=30, 
                                                  signal="signal_bkgdSubtract",
                                                  mixed_model=F)
                             return(tmp)
                           } else {
                             return(tmp)
                           }
                         })
names(gblock_results) <- gblock_guide_ids
gblock_plots <- lapply(seq_along(gblock_results),
                       function(x) {
                         guide_id <- paste0("NCR_", names(gblock_results)[x])
                         which_row <- match(guide_id, guide_features$NCR.id)
                         has_hairpin <- guide_features$has_crRNA_hairpin[which_row]
                         spacer_bp <- guide_features$crRNA_spacer_basepairs[which_row]
                         plot_subtitle <- paste(ifelse(has_hairpin, "has hairpin", "no hairpin"), "|",
                                                spacer_bp, "basepaired positions in spacer")
                         gblock_results[[x]]$plot + ggtitle(guide_id, subtitle=plot_subtitle)
                       })
names(gblock_plots) <- gblock_guide_ids

gblock_coef <- lapply(gblock_results, function(x) x$coef)
gblock_coef <- do.call(rbind, gblock_coef)
gblock_rate <- subset(gblock_coef, grepl(":", gblock_coef$coef))
gblock_rate <- subset(gblock_rate, gblock_rate$guide_id %in% guide_rate$guide_id)

# annotate guide_rate with gblock rate
guide_rate$gblock_rate_round1 <- NA
guide_rate$gblock_rate_round1[match(gblock_round1_data$NCR.ID,
                                    guide_rate$NCR.id)] <- gblock_round1_data$X100.fM.Activator.above.noActivator
guide_rate$gblock_rate_round2[match(paste0("NCR_", gblock_rate$guide_id),
                                    guide_rate$NCR.id)] <- gblock_rate$Estimate
(ggplot(subset(guide_rate, !is.na(gblock_rate_round1)), 
        aes(x=Estimate, y=gblock_rate_round1)) + 
    geom_point(alpha=0.5) + theme_bw() + ggtitle("gBlock: round 1") +
    geom_smooth(method=lm, formula=y~x) +
    xlab("viral RNA: activator-dependent rate (RFU/min)") + 
    ylab("gBlocks: activator-dependent rate (RFU/min)") +
    annotate(geom="text", x=-Inf, y=Inf, 
             label=paste("cor =", round(with(guide_rate, 
                                             cor(Estimate, gblock_rate_round1, 
                                                 use="pairwise.complete.obs",
                                                 method="spearman")),
                                        digits=3)),
             hjust=-0.25, vjust=2, col="red")) + 
  (ggplot(guide_rate, aes(x=Estimate, y=gblock_rate_round2)) +
     geom_point(alpha=0.5) + theme_bw() + 
     geom_smooth(method=lm, formula=y~x) +
     xlab("viral RNA: activator-dependent rate (RFU/min)") +
     ylab("gBlocks: activator-dependent rate (RFU/min)") +
     ggtitle("gBlock: round 2") + ylim(0, 170) + 
     annotate(geom="text", x=-Inf, y=Inf, 
              label=paste("cor =", round(with(guide_rate, 
                                              cor(Estimate, gblock_rate_round2, 
                                                  use="pairwise.complete.obs",
                                                  method="spearman")),
                                         digits=3)),
              hjust=-0.25, vjust=2, col="red")) + 
  (ggplot(subset(guide_rate, !is.na(gblock_rate_round1)),
          aes(x=gblock_rate_round1, y=gblock_rate_round2)) + 
     geom_point(alpha=0.5) + geom_smooth(method="lm", formula=y~x) + 
     theme_bw() + xlab("round 1 (RFU/min)") + ylab("round 2 (RFU/min)") + 
     ggtitle("gBlocks: round 1 vs. round 2") + 
     annotate(geom="text", x=-Inf, y=Inf,
              label=paste("cor =", round(with(guide_rate,
                                              cor(gblock_rate_round1, 
                                                  gblock_rate_round2,
                                                  use="pairwise.complete.obs",
                                                  method="spearman")),
                                         digits=3)),
              hjust=-0.25, vjust=2, col="red"))
```

```{r save_gblock_traces, message=F}
trace_gblock_dir <- file.path(traces_dir, "gblock")
if(!dir.exists(trace_gblock_dir)) { dir.create(trace_gblock_dir) }
for(x in seq_along(all_plots)) {
  ggsave(filename=file.path(trace_gblock_dir, 
                            paste0("NCR_", names(gblock_plots)[x], ".pdf")),
         plot=all_plots[[x]], device="pdf")
}
```

gBlock round 2 outlier:

```{r gblock_NCR_1352}
gblock_plots[["1352"]]
```

```{r test_antitag}
# choose 4 guides with GRRR anti-tag and low activity
# also: good guide secondary structure
antitag_G <- subset(guide_rate, 
                    antitag_label=="G" &has_crRNA_hairpin & crRNA_spacer_basepairs==0)
antitag_G <- antitag_G[, c("NCR.id", "start", "spacer", "Estimate", "antitag", "antitag_label")]
antitag_G <- antitag_G[order(antitag_G$Estimate),]
antitag_G <- antitag_G[1:4,]

# choose 2 guides w/o G anti-tag and high activity
antitag_notG <- subset(guide_rate, 
                       antitag_pos1 != "G" & has_crRNA_hairpin & crRNA_spacer_basepairs==0)
antitag_notG <- antitag_notG[, c("NCR.id", "start", "spacer", "Estimate", "antitag", "antitag_label")]
antitag_notG <- antitag_notG[order(antitag_notG$Estimate, decreasing=T),]
antitag_notG <- antitag_notG[c(2,4),]

old_repeat <- toupper("uagaccaccccaaaaaugaaggggacuaaaac")
new_repeats <- data.frame(new_tag_pos1=c("A", "U", "G"))
new_repeats$new_repeat <- sapply(new_repeats$new_tag_pos1,
                                 function(x) {
                                   paste0(substr(old_repeat, 1, 
                                                 nchar(old_repeat)-1), x)
                                 })

test_antitag <- rbind(antitag_G, antitag_notG)
test_antitag <- expand.grid.df(test_antitag, new_repeats)
test_antitag$crRNA_seq <-paste0(test_antitag$new_repeat, test_antitag$spacer)
test_antitag <- test_antitag[order(test_antitag$start),]

test_antitag$new_NCR_id <- paste0("NCR_", 1629:1646)

write.csv(test_antitag, row.names=F,
          file=file.path(project_dir, "test_antitag_G.csv"))
```

# Figures for paper

```{r make_figure_directory}
figure_dir <- file.path(here(), "NCR", "figures")
if(!dir.exists(figure_dir)) { dir.create(figure_dir) }
```

```{r remove_28mers}
guide_rate <- subset(guide_rate, nchar(spacer)==20)
```

Figure 1A (data): guide design pipeline

```{r figure_1A}
# all guides targeting SARS-CoV-2: n=29,880
design_data <- read.table(file.path(here(), "outputs", "covid", "cas13a_20nt", 
                                    "cas13a_results_summary.txt")) 
# filter out 4nt of antitag complementarity: n=29,658
design_data <- subset(design_data, antitag != "GUUU")
# filter for specificity: n = 11287
design_data <- subset(design_data,
                      specificity == 1 &
                        match_against_hg38 == 0 &
                        match_against_bosTau9 == 0)
# filter for sensitivity  0.95: n = 11,139
design_data <- subset(design_data, sensitivity_01 >= 0.95)
```

Figure 2A: range of observed guide activities 

```{r figure_2A}
gene_bed <- read.table(file.path(here(), "ref_data", "cov2_genes.txt"),
                       comment.char="@", header=T)
gene_bed$overlap <- c(F, 
                      sapply(2:nrow(gene_bed),
                             function(x) {
                               gene_bed$thickStart[x] < (gene_bed$thickEnd[x-1]+50)
                             }))
gene_bed$ymax <- NA
for(x in seq(nrow(gene_bed))) {
  if(x==1) {
    gene_bed$ymax[x] <- -15
  } else {
    gene_bed$ymax[x] <- ifelse(gene_bed$overlap[x],
                               ifelse(gene_bed$ymax[x-1]==-15, -20, -15),
                               ifelse(gene_bed$ymax[x-1]==-15, -15, -20))
  }
}

(ggplot(guide_rate, aes(x=start, y=Estimate)) + theme_classic() + 
    geom_point() + geom_errorbar(aes(ymin=Estimate+qnorm(0.05)*Std.Error,
                                     ymax=Estimate-qnorm(0.05)*Std.Error)) + 
    xlab("position along genome") + ylab("activator-dependent rate\n(RFU/min)") + ylim(-10, 100) + 
    theme(axis.title=element_text(size=10), 
          axis.text=element_text(size=10))) + 
  (ggplot(gene_bed, aes(xmin=thickStart, xmax=thickEnd, ymin=ymax-4.5, ymax=ymax)) + 
     theme_void() + geom_rect() + 
     geom_text(data=subset(gene_bed, thickEnd-thickStart > 300*nchar(geneName)),
               aes(x=(thickStart + thickEnd)/2, y=ymax-(4.5/2), label=name),
               col="white", size=2.5)) +
  (ggplot(guide_rate, aes(y=Estimate)) + theme_classic() + 
     geom_histogram(binwidth=5) + xlab("") + ylab("") + ylim(-10, 100) + 
     theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
           axis.text.x=element_text(size=10)) + 
     scale_x_continuous(breaks=c(0, 20))) + 
  plot_spacer() + 
  plot_layout(byrow=F, widths=c(10,1), heights=c(5,1))

ggsave(filename=file.path(figure_dir, "figure_2A.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3, units="in")
```

Figure 2B: example traces

```{r figure_2B_data}
time_start <- 15
signal <- "signal_bkgdSubtract"

### NCR_527
data_527 <- subset(plate_data, guide_id=="527")
data_527$activator <- relevel(data_527$activator, ref="noActivator")
time_stop <- signif(max(data_527$time))
# compute fit
fit_527 <- nlme::lme(formula(paste(signal, "~ time*activator")),
                     random = ~ 1 + time | well_384, 
                     data = subset(data_527, time >= time_start))
# predict trajectory
fit_coef_527 <- summary(fit_527)$tTable[,1]
data_predict_noActivator_527 <- data.frame(time=seq(time_start, time_stop, 1),
                                           activator="noActivator")
data_predict_noActivator_527[[signal]] <- fit_coef_527["(Intercept)"] + 
  data_predict_noActivator_527$time * fit_coef_527["time"]
data_predict_100fM_527 <- data.frame(time=seq(time_start, time_stop, 1),
                                 activator="100fM")
data_predict_100fM_527[[signal]] <- fit_coef_527["(Intercept)"] + 
  fit_coef_527["activator100fM"] +
  data_predict_100fM_527$time * (fit_coef_527["time"] + fit_coef_527["time:activator100fM"])
data_predict_527 <- rbind(data_predict_noActivator_527, data_predict_100fM_527)
# pull fixed effects
coef_527 <- data.frame(summary(fit_527)$tTable, guide_id="527",
                         coef=rownames(summary(fit_527)$varFix), row.names=NULL)
colnames(coef_527)[colnames(coef_527)=="Value"] <- "Estimate"
coef_527 <- coef_527[, -which(colnames(coef_527)=="DF")]
# make plot
max_527 <- max(data_527[[signal]], na.rm=T)
width_527 <- max(data_527[[signal]], na.rm=T) - min(data_527[[signal]], na.rm=T)
rate_noActivator_527 <- fit_coef_527["time"]
rate_100fM_527 <- fit_coef_527["time"] + fit_coef_527["time:activator100fM"]
plot_text_527 <- data.frame(x=10,
                            y=max_527 - c(1, 2.5, 4)*width_527/20,
                            text=c(paste("RNP-only rate:", signif(rate_noActivator_527, 3)),
                                   paste("100 fM rate:", signif(rate_100fM_527, 3)),
                                   paste("p =", 
                                         signif(subset(coef_527, coef=="time:activator100fM")$p.value, 3))))

### NCR_505
data_505 <- subset(plate_data, guide_id=="505")
data_505$activator <- relevel(data_505$activator, ref="noActivator")
time_stop <- signif(max(data_505$time))
# compute fit
fit_505 <- nlme::lme(formula(paste(signal, "~ time*activator")),
                     random = ~ 1 + time | well_384, 
                     data = subset(data_505, time >= time_start))
# predict trajectory
fit_coef_505 <- summary(fit_505)$tTable[,1]
data_predict_noActivator_505 <- data.frame(time=seq(time_start, time_stop, 1),
                                           activator="noActivator")
data_predict_noActivator_505[[signal]] <- fit_coef_505["(Intercept)"] + 
  data_predict_noActivator_505$time * fit_coef_505["time"]
data_predict_100fM_505 <- data.frame(time=seq(time_start, time_stop, 1),
                                 activator="100fM")
data_predict_100fM_505[[signal]] <- fit_coef_505["(Intercept)"] + 
  fit_coef_505["activator100fM"] +
  data_predict_100fM_505$time * (fit_coef_505["time"] + fit_coef_505["time:activator100fM"])
data_predict_505 <- rbind(data_predict_noActivator_505, data_predict_100fM_505)
# pull fixed effects
coef_505 <- data.frame(summary(fit_505)$tTable, guide_id="505",
                         coef=rownames(summary(fit_505)$varFix), row.names=NULL)
colnames(coef_505)[colnames(coef_505)=="Value"] <- "Estimate"
coef_505 <- coef_505[, -which(colnames(coef_505)=="DF")]
# make plot
max_505 <- max(data_505[[signal]], na.rm=T)
width_505 <- max(data_505[[signal]], na.rm=T) - min(data_505[[signal]], na.rm=T)
rate_noActivator_505 <- fit_coef_505["time"]
rate_100fM_505 <- fit_coef_505["time"] + fit_coef_505["time:activator100fM"]
plot_text_505 <- data.frame(x=10,
                            y=max_505 - c(1, 2.5, 4)*width_505/20,
                            text=c(paste("RNP-only rate:", signif(rate_noActivator_505, 3)),
                                   paste("100 fM rate:", signif(rate_100fM_505, 3)),
                                   paste("p =", 
                                         signif(subset(coef_505, coef=="time:activator100fM")$p.value, 3))))
```

```{r figure_2B_plot}
guide_plot_527 <- ggplot(data_predict_527, 
                         aes_string(x="time", y=signal, col="activator")) +
  geom_line(size=2) + 
  geom_point(data=data_527, shape=16, alpha=0.75,
             aes_string(x="time", y=signal, col="activator")) +
  # geom_text(data=plot_text_527, aes(x=x, y=y, label=text), 
  #           col="black", hjust=0, size=2.5) +
  theme_classic() + # scale_color_manual(values=c("red", "black")) +
  scale_color_manual(values=c(ucb_colors$`Rose Garden`, ucb_colors$`Lawrence`)) +
  theme(axis.text=element_text(size=10), 
        axis.title=element_text(size=10), 
        plot.title=element_text(size=10)) + 
  ggtitle("target position: 7720-7739",
          subtitle=paste(plot_text_527$text, collapse="\n")) + 
  xlab("time (min)") + ylab("RFU") + guides(col="none")

guide_plot_505 <- ggplot(data_predict_505, 
                         aes_string(x="time", y=signal, col="activator")) +
  geom_line(size=2) + 
  geom_point(data=data_505, shape=16, alpha=0.75, 
             aes_string(x="time", y=signal, col="activator")) +
  # geom_text(data=plot_text_505, aes(x=x, y=y, label=text), 
  #           col="black", hjust=0, size=2.5) +
  theme_classic() + 
  # scale_color_manual(values=c("red", "black"), 
  #                    labels=c("100fM activator", "RNP-only")) +
  scale_color_manual(values=c(ucb_colors$`Rose Garden`, ucb_colors$`Lawrence`),
                     labels=c("100 fM activator", "RNP-only")) +
  theme(axis.text=element_text(size=10), 
        axis.title=element_text(size=10), 
        plot.title=element_text(size=10), 
        legend.position="bottom") + 
  ggtitle("target position: 510-529",
          subtitle=paste(plot_text_505$text, collapse="\n")) +
  xlab("time (min)") + ylab("") + labs(col="")

guide_plot_527 + guide_plot_505
ggsave(filename=file.path(figure_dir, "figure_2B.pdf"),
       plot=last_plot(),
       device="pdf", width=4, height=3.5, units="in")
```

Figure 2C: viral RNA v. gblock 

```{r figure_2C}
# gblock outlier: NCR_1352
virus_v_gblock_data <- subset(guide_rate, NCR.id != "NCR_1352")
(ggplot(virus_v_gblock_data, aes(x=Estimate)) + 
    geom_histogram(binwidth=5) + xlab("") + ylab("") + 
    theme_classic(base_size=10) + scale_y_continuous(breaks=c(0, 20)) +
    theme(axis.text.x=element_blank())) + 
  plot_spacer() +
  (ggplot(virus_v_gblock_data, aes(x=Estimate, y=gblock_rate_round2)) + 
     geom_point(shape=16, alpha=0.75) + 
     # geom_abline(slope=1, intercept=0, linetype="dashed") + 
     xlab("viral genome activity\n(RFU/min)") + 
     ylab("gblock activity\n(RFU/min)") + 
     # annotate(geom="text", x=-Inf, y=Inf, hjust="inward", vjust="inward",
     #          label=paste("  cor =", 
     #                      round(with(virus_v_gblock_data, 
     #                                 cor(Estimate, gblock_rate_round2)), 
     #                            digits=3))) + 
     theme_classic(base_size=10)) + 
  (ggplot(virus_v_gblock_data, aes(y=gblock_rate_round2)) + 
     geom_histogram(binwidth=5) + xlab("") + ylab("") + 
     theme_classic(base_size=10) + scale_x_continuous(breaks=c(0, 50)) + 
     theme(axis.text.x=element_text(angle=-90, vjust=0.5), 
           axis.text.y=element_blank())) + 
  plot_layout(nrow=2, widths=c(4,1), heights=c(1,4))

ggsave(filename=file.path(figure_dir, "figure_2C.pdf"),
       plot=last_plot(),
       device="pdf", width=3, height=3, units="in")
```

Figure 3: elastic net regression + anti-tag result

```{r figure_3}
model1_coefs <- coef(model1_bestfit, s=model1$MSE$best_lambda)[, 1]
model1_coefs <- data.frame(matrix(unlist(strsplit(names(model1_coefs)[-1],
                                                  split="_")),
                                  ncol=3, byrow=T),
                           model1_coefs[-1],
                           row.names=NULL)
colnames(model1_coefs) <- c("type", "position", "coef", "value")
model1_coefs$position <- as.numeric(sub("\\.", "-", model1_coefs$position))

model1_MSE_r2 <- aggregate(r2~split, 
                           data=subset(model1$MSE$all_models_stats, 
                                       alpha==model1$MSE$best_alpha & 
                                         lambda==model1$MSE$best_lambda), 
                           FUN=mean)

(ggplot(model1_coefs, aes(x=position, y=value, fill=coef)) + 
    geom_col(position="stack") + geom_hline(yintercept=0) +
    xlab("position relative to spacer") + ylab("regression coefficient") + 
    # ggtitle("elastic net", 
    #         subtitle=bquote("mean testing"~r^2~"="~
    #                           .(round(model1_MSE_r2$r2[model1_MSE_r2$split=="testing"], 
    #                                   digits=3)))) +
    theme_classic() + labs(fill="") +
    scale_x_continuous(breaks=c(1, 10, 20)) +
    scale_fill_manual(values=c(RColorBrewer::brewer.pal(4, "Set1"), "grey")) +
    theme(axis.text=element_text(size=10), 
          axis.title=element_text(size=10),
          plot.title=element_text(size=10),
          legend.position="bottom") +
    annotate("rect", xmin=0.5, xmax=19.5, ymin=2, ymax=3, fill="black") + 
    annotate("text", x=10.5, y=2.5, label="protospacer", col="white", size=2.5) +
    annotate("rect", xmin=-5.5, xmax=0.5, ymin=2, ymax=3, fill="darkgrey") +
    annotate("text", x=-2, y=2.5, label="anti-tag", col="white", size=2.5)) + 
  (ggplot(guide_rate,
          aes(x=antitag_pos1, y=Estimate, fill=antitag_pos1)) + 
     geom_violin(draw_quantiles=c(0.25, 0.75), linetype="dashed") + 
     geom_violin(fill="transparent", draw_quantiles=0.5) + 
     geom_dotplot(binaxis="y", stackdir="center", binwidth=0.5, fill="black") +
     scale_fill_manual(values=RColorBrewer::brewer.pal(4, "Set1")) +
     theme_classic() + guides(fill="none") +
     theme(axis.text=element_text(size=10), axis.title=element_text(size=10)) + 
     xlab("first position in anti-tag") + ylab("activator-dependent rate\n(RFU/min)"))

ggsave(filename=file.path(figure_dir, "figure_3.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3, units="in")
```

```{r figure_3_ttest}
t.test(x=subset(guide_rate$Estimate,
                guide_rate$antitag_pos1 != "G"),
       y=subset(guide_rate$Estimate,
                guide_rate$antitag_pos1 == "G"),
       alternative="greater")

t.test(x=subset(guide_rate$Estimate, 
                guide_rate$antitag_label=="G"),
       y=subset(guide_rate$Estimate, 
                guide_rate$antitag_label %in% c("GU", "GUU")),
       alternative="greater")
```

Figure 4C: LOD with Cas13-Csm6 tandem assay

```{r figure_4C}
# load platemap
findit_platemap <- xlsx::read.xlsx(file.path(project_dir,
                                             "supplementary_data",
                                             "FIND-IT_multiplex_platemap.xlsx"),
                                   sheetName="Variants Platemap",
                                   rowIndex=2:10, colIndex=2:15, header=T)
findit_platemap <- data.frame(plate_row=rep(LETTERS[seq(nrow(findit_platemap))],
                                            times=ncol(findit_platemap)),
                              plate_col=rep(seq(ncol(findit_platemap)),
                                            each=nrow(findit_platemap)),
                              multiplex=unlist(findit_platemap))
findit_platemap <- subset(findit_platemap, !is.na(multiplex))
findit_platemap$well <- with(findit_platemap, paste0(plate_row, plate_col))
findit_platemap$multiplex <- paste(findit_platemap$multiplex, "crRNAs")
findit_platemap$conc <- ""
findit_conc <- c(125, 63, 31, 16, 8, 4, 0)
for(x in seq_along(findit_conc)) {
  findit_platemap$conc[findit_platemap$plate_col %in% c(2*x-1, 2*x)] <- findit_conc[x]
}

# load data
findit_data <- xlsx::read.xlsx(file.path(project_dir,
                                         "supplementary_data",
                                         "FIND-IT_multiplex.xlsx"),
                               sheetName="Result sheet",
                               rowIndex=82:142)
findit_data <- lapply(seq(nrow(findit_platemap)),
                   function(x) {
                     data.frame(time=findit_data$Time..s.,
                                RFU=findit_data[[findit_platemap$well[x]]],
                                well=findit_platemap$well[x],
                                multiplex=findit_platemap$multiplex[x],
                                conc=findit_platemap$conc[x])
                   })
findit_data <- do.call(rbind, findit_data)
findit_data$time <- round(findit_data$time/60)
findit_data$RFU_norm_6 <- sapply(seq(nrow(findit_data)),
                               function(x) {
                                 tmp <- subset(findit_data,
                                               time == 6 & 
                                                 well == findit_data$well[x])
                                 return(findit_data$RFU[x] / tmp$RFU)
                               })
findit_data$RFU_norm_10 <- sapply(seq(nrow(findit_data)),
                               function(x) {
                                 tmp <- subset(findit_data,
                                               time == 10 & 
                                                 well == findit_data$well[x])
                                 return(findit_data$RFU[x] / tmp$RFU)
                               })

# ggplot(subset(findit_data, multiplex != "No Protein"),
#        aes(x=time, y=RFU, col=factor(conc, levels=findit_conc))) +
#   stat_summary(fun="mean", geom="line") + 
#   stat_summary(fun="mean", geom="point", size=0.5) + 
#   stat_summary(fun.data="mean_se", geom="errorbar") + 
#   facet_grid(~factor(multiplex, levels=c("8 crRNAs", "32 crRNAs"))) + 
#   theme_classic() + labs(col="")

findit_detection_120 <- lapply(unique(findit_platemap$multiplex),
                           function(tmp_pool) {
                             do.call(rbind,
                                     lapply(findit_conc[-length(findit_conc)],
                                            function(tmp_conc) {
                                              tmp_data <- subset(findit_data,
                                                                 time %in% max(time) & 
                                                                   multiplex==tmp_pool &
                                                                   conc %in% c(tmp_conc, 0))
                                              tmp_p <- t.test(subset(tmp_data, 
                                                                     conc==tmp_conc)$RFU,
                                                              subset(tmp_data,
                                                                     conc==0)$RFU,
                                                              alternative="greater")
                                              tmp_p_norm_6 <- t.test(subset(tmp_data, 
                                                                            conc==tmp_conc)$RFU_norm_6,
                                                                     subset(tmp_data,
                                                                            conc==0)$RFU_norm_6,
                                                                     alternative="greater")
                                              tmp_p_norm_10 <- t.test(subset(tmp_data, 
                                                                             conc==tmp_conc)$RFU_norm_10,
                                                                      subset(tmp_data,
                                                                             conc==0)$RFU_norm_10,
                                                                      alternative="greater")
                                              return(data.frame(multiplex=tmp_pool,
                                                                conc=tmp_conc,
                                                                p=tmp_p$p.value,
                                                                p_norm_6=tmp_p_norm_6$p.value,
                                                                p_norm_10=tmp_p_norm_10$p.value))
                                            }))
                           })
findit_detection_120 <- do.call(rbind, findit_detection_120)
findit_detection_120$text <- label_p(findit_detection_120$p)
findit_detection_120$text_norm_6 <- label_p(findit_detection_120$p_norm_6)
findit_detection_120$text_norm_10 <- label_p(findit_detection_120$p_norm_10)
findit_detection_120$text_height <- sapply(seq(nrow(findit_detection_120)),
                                       function(x) {
                                         tmp_data <- subset(findit_data,
                                                            multiplex==findit_detection_120$multiplex[x] &
                                                              conc==findit_detection_120$conc[x] & 
                                                              time==max(time))
                                         return(mean(tmp_data$RFU_norm_10))
                                       })

findit_detection_30 <- lapply(unique(findit_platemap$multiplex),
                              function(tmp_pool) {
                                do.call(rbind,
                                        lapply(findit_conc[-length(findit_conc)],
                                               function(tmp_conc) {
                                                 tmp_data <- subset(findit_data,
                                                                    time %in% 30 & 
                                                                      multiplex==tmp_pool &
                                                                      conc %in% c(tmp_conc, 0))
                                                 tmp_p <- t.test(subset(tmp_data, 
                                                                        conc==tmp_conc)$RFU,
                                                                 subset(tmp_data,
                                                                        conc==0)$RFU,
                                                                 alternative="greater")
                                                 tmp_p_norm_6 <- t.test(subset(tmp_data, 
                                                                               conc==tmp_conc)$RFU_norm_6,
                                                                        subset(tmp_data,
                                                                               conc==0)$RFU_norm_6,
                                                                        alternative="greater")
                                                 tmp_p_norm_10 <- t.test(subset(tmp_data, 
                                                                                conc==tmp_conc)$RFU_norm_10,
                                                                         subset(tmp_data,
                                                                                conc==0)$RFU_norm_10,
                                                                         alternative="greater")
                                                 return(data.frame(multiplex=tmp_pool,
                                                                   conc=tmp_conc,
                                                                   p=tmp_p$p.value,
                                                                   p_norm_6=tmp_p_norm_6$p.value,
                                                                   p_norm_10=tmp_p_norm_10$p.value))
                                               }))
                              })
findit_detection_30 <- do.call(rbind, findit_detection_30)
findit_detection_30$text <- label_p(findit_detection_30$p)
findit_detection_30$text_norm_6 <- label_p(findit_detection_30$p_norm_6)
findit_detection_30$text_norm_10 <- label_p(findit_detection_30$p_norm_10)
findit_detection_30$text_height <- sapply(seq(nrow(findit_detection_30)),
                                          function(x) {
                                            tmp_data <- subset(findit_data,
                                                               multiplex==findit_detection_30$multiplex[x] &
                                                                 conc==findit_detection_30$conc[x] & 
                                                                 time==30)
                                            return(mean(tmp_data$RFU_norm_10))
                                          })

findit_2h <- ggplot(subset(findit_data, time == max(time)), 
       aes(x=factor(conc, levels=findit_conc), y=RFU_norm_10,
           fill=factor(conc, levels=findit_conc))) + 
  stat_summary(fun="mean", geom="bar", width=0.75) + 
  stat_summary(fun.data="mean_se", geom="errorbar", width=0.5) + 
  theme_classic(base_size=10) + labs(fill="") + xlab("") + 
  facet_grid(~factor(multiplex, levels=c("8 crRNAs", "32 crRNAs")),
             scales="free_x", space="free_x") + 
  geom_text(data=findit_detection_120, size=3,
            aes(y=text_height + 0.25, label=text_norm_10)) + 
  xlab(expr(copies/mu*L)) + ylab(expr(RFU / RFU[10]))

findit_30min <- ggplot(subset(findit_data, time == 30), 
       aes(x=factor(conc, levels=findit_conc), y=RFU_norm_10,
           fill=factor(conc, levels=findit_conc))) + 
  stat_summary(fun="mean", geom="bar", width=0.75) + 
  stat_summary(fun.data="mean_se", geom="errorbar", width=0.5) + 
  theme_classic(base_size=10) + labs(fill="") + xlab("") + 
  facet_grid(~factor(multiplex, levels=c("8 crRNAs", "32 crRNAs")),
             scales="free_x", space="free_x") + 
  geom_text(data=findit_detection_30, size=3,
            aes(y=text_height + 0.05, label=text_norm_10)) + 
  xlab(expr(copies/mu*L)) + ylab(expr(RFU / RFU[10]))
```


Figure 4D: robustness to genetic variants

```{r figure_4D}
# load platemap
variants_platemap <- xlsx::read.xlsx(file.path(project_dir,
                                               "supplementary_data",
                                               "Variants_1 Platemap.xlsx"),
                                     sheetName="Variants Platemap",
                                     rowIndex=2:12, colIndex=2:25, header=T)
variants_platemap <- data.frame(plate_row=rep(LETTERS[seq(nrow(variants_platemap))],
                                        times=ncol(variants_platemap)),
                                plate_col=rep(seq(ncol(variants_platemap)),
                                        each=nrow(variants_platemap)),
                                variant=unlist(variants_platemap))
variants_platemap <- subset(variants_platemap, !is.na(variant))
variants_platemap$variant[variants_platemap$variant=="B.1.17"] <- "alpha: B.1.1.7"
variants_platemap$variant[variants_platemap$variant=="B.1.351"] <- "beta: B.1.351"
variants_platemap$variant[variants_platemap$variant=="B.1.617.1"] <- "delta: B.1.617.1"
variants_platemap$variant[variants_platemap$variant=="P.1"] <- "gamma: P.1"
variants_platemap$well <- with(variants_platemap, paste0(plate_row, plate_col))
variants_platemap$multiplex <- ""
variants_platemap$multiplex[(variants_platemap$plate_row %in% c("A", "B")) & 
                         (variants_platemap$plate_col %in% 3:4)] <- "multiplex_8"
variants_platemap$multiplex[variants_platemap$plate_col %in% 5:14] <- "multiplex_8"
variants_platemap$multiplex[(variants_platemap$plate_row %in% c("C", "D")) & 
                         (variants_platemap$plate_col %in% 3:4)] <- "multiplex_32"
variants_platemap$multiplex[variants_platemap$plate_col %in% 15:24] <- "multiplex_32"
variants_platemap$conc <- ""
variants_platemap$conc[variants_platemap$plate_col %in% c(5:6, 15:16)] <- "10 fM"
variants_platemap$conc[variants_platemap$plate_col %in% c(7:8, 17:18)] <- "1 fM"
variants_platemap$conc[variants_platemap$plate_col %in% c(9:10, 19:20)] <- "100 aM"
variants_platemap$conc[variants_platemap$plate_col %in% c(11:12, 21:22)] <- "10 aM"
variants_platemap$conc[variants_platemap$plate_col %in% c(13:14, 23:24)] <- "1 aM"
variants_platemap$sample <- with(variants_platemap, paste(variant, multiplex, conc, sep="_"))
variants_platemap <- subset(variants_platemap, variant != "No Protein")

# load data
variants_data <- xlsx::read.xlsx(file.path(project_dir,
                                           "supplementary_data", 
                                           "Variants_1.xlsx"),
                                 sheetName="Sheet2",
                                 rowIndex=41:102, header=T)
variants_data <- lapply(seq(nrow(variants_platemap)),
                   function(x) {
                     data.frame(time=variants_data$Time..s.,
                                RFU=variants_data[[variants_platemap$well[x]]],
                                well=variants_platemap$well[x],
                                variant=variants_platemap$variant[x],
                                multiplex=variants_platemap$multiplex[x],
                                conc=variants_platemap$conc[x])
                   })
variants_data <- do.call(rbind, variants_data)
variants_data$time <- variants_data$time/60

# slopes start to diverge at 10min mark --> take data from timepoints after 10min
# ggplot(variants_data, aes(x=time, y=RFU)) + geom_point() + geom_vline(xintercept=10)

# calculate slopes
variant_slopes <- lapply(unique(variants_data$multiplex),
                         function(tmp_pool) {
                           do.call(rbind, 
                                   lapply(unique(variants_data$variant)[-1],
                                          function(tmp_variant) {
                                            tmp_data <- subset(variants_data,
                                                               multiplex == tmp_pool &
                                                                 variant %in% c(tmp_variant, "No Activator"))
                                            tmp_model <- lm(RFU ~ time * conc, tmp_data)
                                            tmp_coef <- data.frame(summary(tmp_model)$coefficients,
                                                                   multiplex=tmp_pool,
                                                                   variant=tmp_variant)
                                            tmp_coef <- subset(tmp_coef, grepl("time:", rownames(tmp_coef)))
                                            tmp_coef$conc <- sub("time:conc", "", rownames(tmp_coef))
                                            return(tmp_coef)
                                          }))
                         })
variant_slopes <- do.call(rbind, variant_slopes)
variant_slopes$conc <- factor(variant_slopes$conc,
                              levels=c("1 aM", "10 aM", "100 aM", "1 fM", "10 fM"))
variant_slopes$variant <- factor(variant_slopes$variant,
                                 levels=c("WT", 
                                          "alpha: B.1.1.7",
                                          "beta: B.1.351",
                                          "gamma: P.1",
                                          "delta: B.1.617.1"))
variant_slopes$multiplex <- factor(variant_slopes$multiplex, 
                                   levels=c("multiplex_8", "multiplex_32"))
variant_slopes$text <- ifelse(variant_slopes$Pr...t.. < 0.05 & 
                                variant_slopes$Estimate > 0,
                              "*", "")

ggplot(variant_slopes, aes(x=conc, y=Estimate, fill=multiplex)) + 
  geom_col(position="dodge2") + 
  facet_grid(~variant, scales="free_x", space="free_x") +
  geom_errorbar(aes(ymin=Estimate + qnorm(0.025) * Std..Error,
                    ymax=Estimate - qnorm(0.025) * Std..Error),
                position=position_dodge2()) + 
  theme_classic(base_size=10) + xlab("") + ylab("activator-dependent rate\n(RFU/min)") + 
  scale_fill_manual(values=c(ucb_colors$`Rose Garden`, ucb_colors$`Lawrence`),
                    labels=c("8", "32")) + 
  labs(fill="multiplex\npool") + 
  theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) + 
  geom_text(aes(x=conc, y=Estimate - qnorm(0.025) * Std..Error + 2, label=text),
            position=position_dodge2(width=0.9))

ggsave(file=file.path(figure_dir, "figure_4D.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3, units="in")
```

Suppl. Figure 1A: random forest variable importance

```{r suppl_figure_1A}
ggplot(model1_rf_regression_importance, 
       aes(x=position, y=increaseMSE, fill=coef)) + 
  geom_col(position="stack") + geom_hline(yintercept=0) +
  xlab("position relative to spacer") + ylab("mean decrease in accuracy") +
  theme_classic(base_size=10) + labs(fill="") +
  scale_x_continuous(breaks=c(1, 10, 20)) + 
  scale_fill_manual(values=c(RColorBrewer::brewer.pal(4, "Set1"), "grey")) +
  annotate("rect", xmin=1, xmax=20, ymin=-10, ymax=-5, fill="black") + 
  annotate("text", x=10.5, y=-7.5, label="protospacer", col="white", size=2.5) +
  annotate("rect", xmin=-5, xmax=1, ymin=-10, ymax=-5, fill="darkgrey") +
  annotate("text", x=-2, y=-7.5, label="anti-tag", col="white", size=2.5) + 
  ggtitle("random forest regression", 
          subtitle=bquote("mean testing"~r^2~"="~
                            .(round(model1_rf_regression_r2, digits=3)))) + 
  theme(legend.position="bottom")

ggsave(file=file.path(figure_dir, "suppl_figure_1A.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3, units="in")
```

Suppl. Figure 1B: sequence logo

```{r suppl_figure_1B}
(ggseqlogo(topSpacers_info, method="custom") + 
  ggtitle(paste("Top", num_spacers, "spacers")) + ylim(0, 0.5) + 
   theme_classic(base_size=10)) / 
  (ggseqlogo(bottomSpacers_info, method="custom") +
     ggtitle(paste("Bottom", num_spacers, "spacers")) + ylim(0, 0.5) +
     theme_classic(base_size=10))

ggsave(file=file.path(figure_dir, "suppl_figure_1B.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3, units="in")
```

Suppl. Figure 2A: GC content

```{r suppl_figure_2A}
GC_cor <- with(guide_rate, cor.test(GC_content, Estimate))
GC_text <- data.frame(x=Inf,
                      y=c(75, 65),
                      text=c(paste("cor =",
                                   round(GC_cor$estimate, digits=3)),
                             paste("p =", signif(GC_cor$p.value, digits=3))))

(ggplot(guide_rate, aes(x=GC_content, y=Estimate)) + theme_classic(base_size=10) + 
    geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) + 
    xlab("spacer %GC") + ylab("activator-dependent rate\n(RFU/min)") +
    geom_text(data=GC_text, col="red", hjust="inward", size=2.5,
              aes(x=x, y=y, label=text)))

ggsave(file=file.path(figure_dir, "suppl_figure_2A.pdf"),
       plot=last_plot(),
       device="pdf", width=3, height=2, units="in")
```

Suppl. Figure 2B: hybridization MFE

```{r suppl_figure_2B}
hyb_MFE_cor <- with(guide_rate, cor.test(hybridization_MFE, Estimate))
hyb_MFE_text <- data.frame(x=Inf,
                           y=c(77, 65),
                           text=c(paste("cor =",
                                        round(hyb_MFE_cor$estimate, digits=3)),
                                  paste("p =", signif(hyb_MFE_cor$p.value, digits=3))))

ggplot(guide_rate, aes(x=hybridization_MFE, y=Estimate)) + 
  geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) + 
  theme_classic(base_size=10) + 
  xlab("hybridization MFE (kcal/mol)") + 
  ylab("activator-dependent rate\n(RFU/min)") + 
  geom_text(data=hyb_MFE_text, col="red", hjust="inward", size=2.5,
            aes(x=x, y=y, label=text))

ggsave(file=file.path(figure_dir, "suppl_figure_2B.pdf"),
       plot=last_plot(),
       device="pdf", width=3, height=2, units="in")
```

Suppl. Figure 2C: cleaveable U in target context

```{r suppl_figure_2C}
U_context_data <- data.frame(Estimate=rep(guide_rate$Estimate, times=2),
                             U_context=c(guide_rate$U_context, 
                                         guide_rate$U_context_unstructured),
                             structure=rep(c("structured + unstructured", 
                                             "unstructured"),
                                           each=nrow(guide_rate)))
U_context_cor <- list(both=cor.test(guide_rate$Estimate, 
                                    guide_rate$U_context),
                      unstructured=cor.test(guide_rate$Estimate, 
                                            guide_rate$U_context_unstructured))
U_context_text <- data.frame(x=Inf,
                             y=rep(c(75, 65), each=2),
                             text=c(paste("cor =",
                                          round(sapply(U_context_cor, function(x) x$estimate),
                                                digits=3)),
                                    paste("p =", signif(sapply(U_context_cor, function(x) x$p.value),
                                                        digits=3))),
                             structure=rep(c("structured + unstructured", "unstructured"),
                                           times=2))

ggplot(U_context_data, aes(x=U_context, y=Estimate)) + 
  geom_point() + geom_smooth(method=lm, formula=y~x) + 
  facet_grid(~structure, scales="free_x") + 
  theme_classic(base_size=10) + 
  xlab("%U in target context") + 
  ylab("activator-dependent rate\n(RFU/min)") + 
  geom_text(data=U_context_text, col="red", hjust="inward", size=2.5,
            aes(x=x, y=y, label=text))

ggsave(file=file.path(figure_dir, "suppl_figure_2C.pdf"),
       plot=last_plot(),
       device="pdf", width=4, height=2.5, units="in")
```

Suppl. Figure 3A: spacer structure

```{r suppl_figure_3A}
# noActivator_structure <- lm(Estimate ~ as.numeric(as.character(crRNA_spacer_basepairs)),
#                             data=subset(noActivator_rate, 
#                                         crRNA_spacer_basepairs %in% c(0, 4, 10, 16)))
# noActivator_structure_coef <- coef(noActivator_structure)[2]
# noActivator_structure_pvalue <- data.frame(summary(noActivator_structure)$coefficients)$Pr...t..[2]
noActivator_structure_antitag <- lapply(unique(noActivator_rate$antitag_pos1),
                                   function(x) {
                                     tmp_data <- subset(noActivator_rate,
                                                        crRNA_spacer_basepairs %in% c(0, 4, 10, 16) &
                                                          antitag_pos1==x)
                                     tmp_data$crRNA_spacer_basepairs <- as.numeric(as.character(tmp_data$crRNA_spacer_basepairs))
                                     data.frame(summary(lm(Estimate ~ crRNA_spacer_basepairs,
                                                           data=tmp_data))$coefficients,
                                                antitag_pos1=x)
                                   })
noActivator_structure_antitag <- do.call(rbind, noActivator_structure_antitag)
noActivator_structure_antitag_text <- data.frame(x=-1, 
                                            y=rep(c(25, 22.5), each=4),
                                            text=c(paste("slope =",
                                                         round(noActivator_structure_antitag$Estimate[2*(1:4)],
                                                               digits=3)),
                                                   paste("p =",
                                                         signif(noActivator_structure_antitag$Pr...t..[2*(1:4)],
                                                               digits=3))),
                                            antitag_pos1=rep(unique(noActivator_structure_antitag$antitag_pos1), 
                                                             times=2))
noActivator_structure_rate <- lm(Estimate ~ as.numeric(as.character(crRNA_spacer_basepairs)),
                                 data=subset(noActivator_rate, 
                                             crRNA_spacer_basepairs %in% c(0, 4, 10, 16)))
noActivator_structure_rate <- data.frame(summary(noActivator_structure_rate)$coefficients)

spacer_structure_antitag <- lapply(unique(guide_rate$antitag_pos1),
                                   function(x) {
                                     tmp_data <- subset(guide_rate,
                                                        crRNA_spacer_basepairs %in% c(0, 4, 10, 16) &
                                                          antitag_pos1==x)
                                     tmp_data$crRNA_spacer_basepairs <- as.numeric(as.character(tmp_data$crRNA_spacer_basepairs))
                                     data.frame(summary(lm(Estimate ~ crRNA_spacer_basepairs,
                                                           data=tmp_data))$coefficients,
                                                antitag_pos1=x)
                                   })
spacer_structure_antitag <- do.call(rbind, spacer_structure_antitag)
spacer_structure_antitag_text <- data.frame(x=-1, 
                                            y=rep(c(85, 75), each=4),
                                            text=c(paste("slope =",
                                                         round(spacer_structure_antitag$Estimate[2*(1:4)],
                                                               digits=3)),
                                                   paste("p =",
                                                         signif(spacer_structure_antitag$Pr...t..[2*(1:4)],
                                                               digits=3))),
                                            antitag_pos1=rep(unique(spacer_structure_antitag$antitag_pos1), 
                                                             times=2))
noActivator_spacer_violin <- ggplot(subset(noActivator_rate, 
                                           crRNA_spacer_basepairs %in% c(0, 4, 10, 16)),
                                    aes(x=as.numeric(as.character(crRNA_spacer_basepairs)), 
                                        y=Estimate)) +
  geom_violin(aes(fill=crRNA_spacer_basepairs),
              draw_quantiles=c(0.25, 0.75), linetype="dashed") +
  geom_violin(aes(fill=crRNA_spacer_basepairs), alpha=0.25, draw_quantiles=0.5) +
  geom_dotplot(aes(fill=crRNA_spacer_basepairs),
               binaxis="y", stackdir="center", binwidth=0.25) +
  geom_smooth(method=lm, formula=y~x) +
  theme_classic() + guides(fill="none") + 
  theme(axis.text=element_text(size=10), axis.title=element_text(size=10)) +
  scale_x_continuous(breaks=c(0, 4, 10, 16)) +
  xlab("# basepaired positions in spacer") +
  ylab("activator-independent rate (RFU/min)")

noActivator_spacer_antitag_violin <- noActivator_spacer_violin + 
  facet_grid(~antitag_pos1) +
  geom_text(data=noActivator_structure_antitag_text,
            aes(x=x, y=y, label=text), hjust=0, size=2.5)

guide_spacer_antitag_violin <- ggplot(subset(guide_rate, 
                                     crRNA_spacer_basepairs %in% c(0, 4, 10, 16)),
                              aes(x=as.numeric(as.character(crRNA_spacer_basepairs)), 
                                  y=Estimate)) + 
  geom_violin(aes(fill=crRNA_spacer_basepairs), 
              draw_quantiles=c(0.25, 0.75), linetype="dashed") + 
  geom_violin(aes(fill=crRNA_spacer_basepairs), alpha=0.25, draw_quantiles=0.5) + 
  geom_dotplot(aes(fill=crRNA_spacer_basepairs), 
               binaxis="y", stackdir="center", binwidth=1) + 
  geom_smooth(method=lm, formula=y~x) + 
  theme_classic() + guides(fill="none") + facet_grid(~antitag_pos1) + 
  theme(axis.text=element_text(size=10), axis.title=element_text(size=10)) +
  scale_x_continuous(breaks=c(0, 4, 10, 16)) + 
  xlab("# basepaired positions in spacer") + 
  ylab("activator-dependent rate\n(RFU/min)") + 
  geom_text(data=spacer_structure_antitag_text, 
            aes(x=x, y=y, label=text), hjust=0, size=2.5)

(noActivator_spacer_violin + 
    annotate(geom="text", x=-1, y=25, size=2.5,
             label=paste("slope =", 
                         round(noActivator_structure_rate$Estimate[2], 
                               digits=3))) +
    annotate(geom="text", x=-1, y=22.5, size=2.5,
             label=paste("p =", 
                         signif(noActivator_structure_rate$Pr...t..[2], 
                                digits=3))) + 
    xlab("# basepaired positions in spacer") + 
    ylab("activatory-independent rate\n(RFU/min)")) / 
  guide_spacer_antitag_violin

ggsave(file=file.path(figure_dir, "suppl_figure_3A.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=4, units="in")
```

Suppl. Figure 3B: structure of direct repeat

```{r suppl_figure_3B}
(ggplot(subset(noActivator_rate, NCR.id %in% guide_rate$NCR.id), 
        aes(x=direct_repeat, y=Estimate)) + 
   theme_classic() + 
   theme(axis.text.x=element_blank(), axis.text.y=element_text(size=10),
         axis.title=element_text(size=10)) + 
   geom_dotplot(binaxis="y", stackdir="center", binwidth=0.25) + 
   xlab("") + ylab("activator-independent rate\n(RFU/min)")) / 
  (ggplot(guide_rate, aes(x=direct_repeat, y=Estimate)) + 
     theme_classic() + 
     theme(axis.text.x=element_text(angle=90, size=10, vjust=0),
           axis.text.y=element_text(size=10),
           axis.title=element_text(size=10)) + 
     geom_dotplot(binaxis="y", stackdir="center", binwidth=1) + 
     xlab("structure of crRNA direct repeat") + 
     ylab("activator-dependent rate\n(RFU/min)"))

ggsave(file=file.path(figure_dir, "suppl_figure_3B.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=4, units="in")
```

Suppl. Figure 4A: in vivo viral structure

```{r suppl_figure_4A}
(lan_huston + theme_classic(base_size=10)) + 
  (sun_invivo_huston + theme_classic(base_size=10)) + 
  (lan_sun_invivo + theme_classic(base_size=10))

ggsave(file=file.path(figure_dir, "suppl_figure_4A.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=2, units="in")
```

Suppl. Figure 4B: genomic structure vs. rate

```{r suppl_figure_4B}
((ggplot(guide_rate, aes(x=lan, y=Estimate)) + theme_classic(base_size=10) +
    geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) +
    xlab("% unstructured") + ylab("activator-dependent rate\n(RFU/min)") + 
    ggtitle("Lan (2020)", subtitle="20nt target region")) + 
    (ggplot(guide_rate, aes(x=huston, y=Estimate)) + theme_classic(base_size=10) +
       geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) +
       xlab("% double-stranded") + ylab("") +
       ggtitle("Huston (2021)", subtitle="20nt target region")) +
    (ggplot(guide_rate, aes(x=sun_invivo, y=Estimate)) + theme_classic(base_size=10) +
       geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) +
       xlab("mean icSHAPE score") + ylab("") +
       ggtitle("Sun (2021)", subtitle="20nt target region"))) / 
  ((ggplot(guide_rate, aes(x=lan_seed, y=Estimate)) + theme_classic(base_size=10) +
    geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) +
    xlab("% unstructured") + ylab("activator-dependent rate\n(RFU/min)") + 
    ggtitle("", subtitle="target seed region")) + 
    (ggplot(guide_rate, aes(x=as.numeric(as.character(huston_seed)), y=Estimate)) + 
       theme_classic(base_size=10) +
       geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) +
       xlab("% double-stranded") + ylab("") +
       ggtitle("", subtitle="target seed region")) +
    (ggplot(guide_rate, aes(x=sun_invivo_seed, y=Estimate)) + theme_classic(base_size=10) +
       geom_point(shape=16) + geom_smooth(method=lm, formula=y~x) +
       xlab("mean icSHAPE score") + ylab("") +
       ggtitle("", subtitle="target seed region")))

ggsave(file=file.path(figure_dir, "suppl_figure_4B.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=4, units="in")
```

Suppl. Figure 5A: multiplex set of 40 vs. primary screen

```{r suppl_figure_5A}
# load plate map (for loo counterscreen)
loo_platemap <- xlsx::read.xlsx(file.path(project_dir, 
                                          "supplementary_data",
                                          "LeaveOneOut Platemap.xlsx"),
                                sheetName="Variants Platemap",
                                rowIndex=3:18, colIndex=2:25, header=F)
loo_platemap <- data.frame(well=paste0(rep(LETTERS[seq(nrow(loo_platemap))],
                                           times=ncol(loo_platemap)),
                                       rep(seq(ncol(loo_platemap)),
                                           each=nrow(loo_platemap))),
                           sample=unlist(loo_platemap))
loo_platemap <- subset(loo_platemap, sample != "<NA>")
loo_samples <- unique(loo_platemap$sample)
loo_samples <- subset(loo_samples, 
                      !grepl(" ", loo_samples) &
                        !grepl("\\+", loo_samples) &
                        !(loo_samples %in% c("8plex", "612")))
guide_rate$multiplex_60 <- sapply(guide_rate$guide_id,
                                  function(x) {
                                    ifelse(x %in% loo_samples,
                                           "multiplex pool", "not selected")
                                  })
guide_rate$multiplex_60 <- factor(guide_rate$multiplex_60,
                                  levels=c("not selected", "multiplex pool"))

# multiplex_40 <- readLines(file.path(project_dir, "40_guide_List.csv"), skip=1)[-1]
# guide_rate$multiplex_40 <- sapply(guide_rate$guide_id,
#                                   function(x) {
#                                     ifelse(x %in% multiplex_40,
#                                            "multiplex pool", "not selected")
#                                   })
# guide_rate$multiplex_40 <- factor(guide_rate$multiplex_40, 
#                                   levels=c("not selected", "multiplex pool"))

(ggplot(guide_rate, aes(x=start, y=Estimate, col=multiplex_60)) + theme_classic() + 
    geom_point() + geom_errorbar(aes(ymin=Estimate+qnorm(0.05)*Std.Error,
                                     ymax=Estimate-qnorm(0.05)*Std.Error)) + 
    xlab("position along genome") + ylab("activator-dependent rate\n(RFU/min)") + 
    ylim(-10, 100) + # scale_color_manual(values=c("black", "red")) +
    scale_color_manual(values=c("black", "red")) +
    theme(axis.title=element_text(size=10), 
          axis.text=element_text(size=10),
          legend.position="none")) /
  (ggplot(gene_bed, aes(xmin=thickStart, xmax=thickEnd, ymin=ymax-4.5, ymax=ymax)) + 
     theme_void() + geom_rect() + 
     geom_text(data=subset(gene_bed, thickEnd-thickStart > 300*nchar(geneName)),
               aes(x=(thickStart + thickEnd)/2, y=ymax-(4.5/2), label=name),
               col="white", size=2.5)) +
  plot_layout(heights=c(5,1))

ggsave(file=file.path(figure_dir, "suppl_figure_5A.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3, units="in")
```

Suppl. Figure 5B: leave-one-out counterscreen

```{r suppl_figure_5B}
# load plate data
loo_data <- xlsx::read.xlsx(file.path(project_dir,
                                      "supplementary_data",
                                      "LeaveOneOut.xlsx"),
                            sheetName="Result sheet",
                            rowIndex=57:117, header=T)
loo_data <- lapply(seq(nrow(loo_platemap)),
                   function(x) {
                     data.frame(time=loo_data$Time..s.,
                                RFU=loo_data[[loo_platemap$well[x]]],
                                well=loo_platemap$well[x],
                                sample=loo_platemap$sample[x])
                   })
loo_data <- do.call(rbind, loo_data)
loo_data$time <- loo_data$time/60

pool_4 <- unique(grep("\\+", loo_data$sample, value=T))
loo_data$pool <- sapply(loo_data$sample,
                        function(x) {
                          if(any(grepl(x, pool_4))) {
                            return(pool_4[grepl(x, pool_4)])
                          } else {
                            return(x)
                          }
                        })

### take slopes dip for first 20 minutes --> estimate slopes after 20min timepoint
# ggplot(loo_data, aes(x=time, y=RFU, col=sample)) + geom_point() + geom_vline(xintercept=20) + 
#   theme_classic() + theme(legend.position="none")

pool4_tests <- lapply(pool_4,
                     function(x) {
                       tmp_data <- subset(loo_data, pool==x & time >= 20)
                       tmp_data$sample <- relevel(as.factor(tmp_data$sample), ref=x)
                       tmp_model <- lm(RFU ~ time * sample, tmp_data)
                       tmp_anova <- anova(tmp_model)
                       tmp_slopes <- emmeans::emtrends(tmp_model, "sample", var="time")
                       tmp_pairs <- data.frame(pairs(tmp_slopes), pool=x)
                       tmp_pairs <- subset(tmp_pairs, grepl("\\(", tmp_pairs$contrast))
                       tmp_slopes <- data.frame(tmp_slopes)
                       tmp_slopes$p_contrast <- tmp_pairs$p.value[match(paste0("(", x, ") - ", 
                                                                               tmp_slopes$sample),
                                                                        tmp_pairs$contrast)]
                       return(tmp_slopes)
                     })
pool4_tests <- do.call(rbind, pool4_tests)

loo_control_tests <- data.frame(emtrends(lm(RFU ~ time * sample, 
                                            subset(loo_data, !(pool %in% pool_4) & 
                                                     time >= 20)), 
                                         "sample", var="time"),
                                p_contrast = NA)

loo_plot_data <- rbind(pool4_tests, loo_control_tests)
loo_plot_data$pool <- sapply(as.character(loo_plot_data$sample),
                             function(x) {
                               if(any(grepl(x, pool_4))) {
                                 return(pool_4[grepl(x, pool_4)])
                               } else {
                                 return(ifelse(x %in% pool_4, x, "control"))
                               }
                             })
levels(loo_plot_data$sample)[levels(loo_plot_data$sample)=="No Act"] <- "RNP-only"
levels(loo_plot_data$sample)[levels(loo_plot_data$sample)=="612"] <- "crRNA control"
loo_plot_data$sample <- sapply(as.character(loo_plot_data$sample),
                               function(x) {
                                 ifelse(grepl("\\+", x) | 
                                          (x %in% c("crRNA control", "8plex", "RNP-only", "No Protein")), 
                                        x, paste0("-", x))
                               })
loo_plot_data$sample <- factor(loo_plot_data$sample, levels=loo_plot_data$sample)
loo_plot_data$text <- ""
loo_plot_data$text[loo_plot_data$p_contrast < 0.05] <- "*"
(ggplot(loo_plot_data, aes(x=sample, y=time.trend, fill=pool)) + geom_col() + 
  geom_errorbar(aes(ymin=lower.CL, ymax=upper.CL)) + geom_hline(yintercept=0) + 
  geom_text(aes(y=time.trend+0.5, label=text)) + 
  theme_classic(base_size=10) + xlab("") + ylab("RFU/min") + 
  theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1),
        legend.position="none"))

ggsave(file=file.path(figure_dir, "suppl_figure_5B.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=4, units="in")
```

Suppl. Figure 5C: human RNA counterscreen

```{r suppl_figure_5C}
# load platemap
human_rna_platemap <- xlsx::read.xlsx(file.path(project_dir,
                                                "supplementary_data", 
                                                "Human RNA Screen Platemap.xlsx"),
                                      sheetName="Variants Platemap",
                                      startRow=2, endRow=18, colIndex=2:25, header=T)
human_rna_platemap <- data.frame(well=paste0(rep(LETTERS[seq(nrow(human_rna_platemap))],
                                                 times=ncol(human_rna_platemap)),
                                             rep(seq(ncol(human_rna_platemap)),
                                                 each=nrow(human_rna_platemap))),
                                 guide=unlist(human_rna_platemap))
human_rna_platemap$human_rna <- sapply(human_rna_platemap$well,
                                       function(x) {
                                         ifelse(substr(x, 1, 1) %in% LETTERS[9:16],
                                                "-", "+")
                                       })
human_rna_platemap$sample <- with(human_rna_platemap, paste(guide, human_rna, sep="_"))
human_rna_platemap <- subset(human_rna_platemap, guide != "<NA>")

# load data
human_rna_data <- xlsx::read.xlsx(file.path(project_dir,
                                            "supplementary_data",
                                            "HumanRNA_1.xlsx"),
                                  sheetName="Result sheet",
                                  rowIndex=55:115, header=T)
human_rna_data <- lapply(seq(nrow(human_rna_platemap)),
                         function(x) {
                           data.frame(time=human_rna_data$Time..s.,
                                      RFU=human_rna_data[[human_rna_platemap$well[x]]],
                                      well=human_rna_platemap$well[x],
                                      guide=human_rna_platemap$guide[x],
                                      human_rna=human_rna_platemap$human_rna[x],
                                      sample=human_rna_platemap$sample[x])
                         })
human_rna_data <- do.call(rbind, human_rna_data)

# compute slopes
human_rna_slopes <- lapply(unique(human_rna_platemap$guide),
                           function(x) {
                             tmp_data <- subset(human_rna_data, guide==x)
                             tmp_model <- lm(RFU ~ time * human_rna, tmp_data)
                             tmp_coef <- data.frame(summary(tmp_model)$coefficients,
                                                    guide=x)
                             tmp_coef$coef <- rownames(tmp_coef)
                             return(tmp_coef)
                           })
human_rna_slopes <- do.call(rbind, human_rna_slopes)
human_rna_slopes <- subset(human_rna_slopes, coef=="time:human_rna+")

human_rna_slopes$type <- "expt"
human_rna_slopes$type[human_rna_slopes$guide %in% c("No Protein", "Apo Protein", "612")] <- "control"
human_rna_slopes$text <- ""
human_rna_slopes$text[p.adjust(human_rna_slopes$Pr...t.., method="fdr")<0.05] <- "*"
human_rna_slopes$guide[human_rna_slopes$guide=="Apo Protein"] <- "RNP-only"
human_rna_slopes$guide[human_rna_slopes$guide=="612"] <- "crRNA control"

ggplot(human_rna_slopes, 
       aes(x=factor(guide, levels=c("No Protein", "RNP-only", "crRNA control",
                                    sort(as.numeric(guide)))), 
           y=Estimate, fill=type)) + 
  geom_col() + theme_classic(base_size=10) + scale_fill_manual(values=c("grey", "black")) + 
  theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1), 
        legend.position="none") + 
  geom_errorbar(aes(ymin=Estimate+qnorm(0.025)*Std..Error, 
                    ymax=Estimate-qnorm(0.025)*Std..Error)) + 
  geom_text(aes(y=Estimate - qnorm(0.025) * Std..Error + 0.005, label=text)) + 
  xlab("") + ylab("activator-dependent rate\n(RFU/min)")

ggsave(file=file.path(figure_dir, "suppl_figure_5C.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3.5, units="in")
```

Suppl. Figure 6: 32-pool vs. 8-pool w/ forced mismatch

```{r suppl_figure_6}
# load platemap
loo_largepool_platemap <- xlsx::read.xlsx(file.path(project_dir,
                                                    "supplementary_data", 
                                                    "LeaveOneOut_LargePool Platemap.xlsx"),
                                          sheetName="Variants Platemap",
                                          startRow=2, endRow=18, colIndex=2:25, header=T)
loo_largepool_platemap <- data.frame(plate_row=rep(LETTERS[seq(nrow(loo_largepool_platemap))],
                                                   times=ncol(loo_largepool_platemap)),
                                     plate_col=rep(seq(ncol(loo_largepool_platemap)),
                                                   each=nrow(loo_largepool_platemap)),
                                     multiplex=unlist(loo_largepool_platemap))
loo_largepool_platemap$well <- with(loo_largepool_platemap, paste0(plate_row, plate_col))
loo_largepool_platemap <- subset(loo_largepool_platemap, multiplex != "<NA>")
loo_largepool_conc <- c("No Protein", "RNP-only", "30 fM", "10 fM", "3 fM", "1 fM", "300 aM")
loo_largepool_platemap$conc <- ""
for(x in seq_along(loo_largepool_conc)) {
  tmp_col <- c(2*x-1, 2*x)
  tmp_conc <- loo_largepool_conc[x]
  loo_largepool_platemap$conc[loo_largepool_platemap$plate_col %in% tmp_col] <- tmp_conc
}
loo_largepool_platemap$sample <- with(loo_largepool_platemap, 
                                      paste(multiplex, conc, sep="_"))

# load data (use findit_75 for gain=75)
loo_largepool_data <- xlsx::read.xlsx(file.path(project_dir,
                                                "supplementary_data",
                                                "LeaveOneOut_LargePool.xlsx"),
                                      sheetName="Result sheet",
                                      rowIndex=101:161, header=T)
loo_largepool_data <- lapply(seq(nrow(loo_largepool_platemap)),
                             function(x) {
                               data.frame(time=loo_largepool_data$Time..s.,
                                          RFU=loo_largepool_data[[loo_largepool_platemap$well[x]]],
                                          well=loo_largepool_platemap$well[x],
                                          multiplex=loo_largepool_platemap$multiplex[x],
                                          conc=loo_largepool_platemap$conc[x],
                                          sample=loo_largepool_platemap$sample[x])
                             })
loo_largepool_data <- do.call(rbind, loo_largepool_data)
loo_largepool_data$time <- loo_largepool_data$time / 60

# compute slopes
loo_largepool_rates <- lapply(unique(loo_largepool_data$sample),
                              function(x) {
                                tmp_data <- subset(loo_largepool_data, sample==x)
                                tmp_model <- lm(RFU ~ time, tmp_data)
                                tmp_coef <- data.frame(summary(tmp_model)$coefficients,
                                                       sample=x)
                                tmp_coef$coef <- rownames(tmp_coef)
                                return(tmp_coef)
                              })
loo_largepool_rates <- do.call(rbind, loo_largepool_rates)
loo_largepool_rates <- subset(loo_largepool_rates, coef=="time")
loo_largepool_rates$conc <- matrix(unlist(strsplit(loo_largepool_rates$sample, split="_")), 
                                          byrow=T, ncol=2)[,2]
loo_largepool_rates$multiplex <- matrix(unlist(strsplit(loo_largepool_rates$sample, split="_")),
                                        byrow=T, ncol=2)[,1]

# compute p-values
loo_largepool_detectable <- lapply(unique(loo_largepool_platemap$multiplex),
                                   function(tmp_pool) {
                                     if(tmp_pool == "No Protein") { return(NULL) }
                                     do.call(rbind,
                                             lapply(loo_largepool_conc[-c(1:2)],
                                                    function(tmp_conc) {
                                                      tmp_data <- subset(loo_largepool_data,
                                                                         multiplex==tmp_pool &
                                                                           conc %in% c("RNP-only", tmp_conc))
                                                      tmp_data$conc <- relevel(as.factor(tmp_data$conc),
                                                                               ref="RNP-only")
                                                      tmp_model <- lm(RFU ~ time * conc, tmp_data)
                                                      tmp_slopes <- data.frame(summary(tmp_model)$coefficients,
                                                                               multiplex=tmp_pool,
                                                                               conc=tmp_conc)
                                                      tmp_slopes$coef <- rownames(tmp_slopes)
                                                      return(tmp_slopes)
                                                    }))
                                   })
loo_largepool_detectable <- do.call(rbind, loo_largepool_detectable)
loo_largepool_detectable <- subset(loo_largepool_detectable, 
                                   grepl("time:", loo_largepool_detectable$coef))
loo_largepool_detectable$label <- ifelse(loo_largepool_detectable$Pr...t.. < 0.05,
                                         "*", "")
## all multiplex pools are detectable above RNP-only at all concentrations
loo_largepool_mismatch <- lapply(loo_largepool_conc[-(1:2)],
                                 function(tmp_conc) {
                                   do.call(rbind,
                                           lapply(c(8, 32),
                                                  function(tmp_pool) {
                                                    if(tmp_pool == 8) {
                                                      tmp_pools <- c("8 Guides", "7 Guides")
                                                    } else {
                                                      tmp_pools <- c("32 Guides", "31 Guides")
                                                    }
                                                    tmp_data <- subset(loo_largepool_data,
                                                                       conc==tmp_conc & 
                                                                         multiplex %in% tmp_pools)
                                                    tmp_data$multiplex <- relevel(as.factor(tmp_data$multiplex),
                                                                                  ref=tmp_pools[1])
                                                    tmp_model <- lm(RFU ~ time*multiplex, tmp_data)
                                                    tmp_coef <- data.frame(summary(tmp_model)$coefficients,
                                                                           multiplex_label = tmp_pools[1],
                                                                           conc=tmp_conc)
                                                    tmp_coef$coef <- rownames(tmp_coef)
                                                    return(tmp_coef)
                                                  }))
                                 })
loo_largepool_mismatch <- do.call(rbind, loo_largepool_mismatch)
loo_largepool_mismatch <- subset(loo_largepool_mismatch,
                                 grepl("time:", loo_largepool_mismatch$coef))
loo_largepool_mismatch$text <- ifelse(loo_largepool_mismatch$Pr...t.. < 0.05,
                                      "*", "")
loo_largepool_mismatch$text_height <- sapply(seq(nrow(loo_largepool_mismatch)),
                                   function(x) {
                                     tmp_pool <- loo_largepool_mismatch$multiplex[x]
                                     tmp_conc <- loo_largepool_mismatch$conc[x]
                                     if(tmp_pool == "8 Guides") {
                                       tmp_pools <- c("8 Guides", "7 Guides")
                                     } else {
                                       tmp_pools <- c("32 Guides", "31 Guides")
                                     }
                                     tmp_data <- subset(loo_largepool_rates,
                                                        multiplex %in% tmp_pools &
                                                          conc == tmp_conc)
                                     return(max(tmp_data$Estimate))
                                   })
loo_largepool_mismatch$multiplex_label <- relevel(as.factor(loo_largepool_mismatch$multiplex_label),
                                                  ref="8 Guides")
loo_largepool_mismatch <- subset(loo_largepool_mismatch, conc != "30 fM" & text == "*")
loo_largepool_mismatch$multiplex_label <- sub("Guides", "crRNAs", loo_largepool_mismatch$multiplex_label)

# format for plotting
loo_largepool_rates$conc <- factor(loo_largepool_rates$conc, levels=loo_largepool_conc)
loo_largepool_rates$mismatch <- ifelse(loo_largepool_rates$multiplex %in% 
                                         c("31 Guides", "7 Guides"),
                                       "mismatch", "no mismatch")
loo_largepool_rates$mismatch[loo_largepool_rates$multiplex == "No Protein"] <- NA
loo_largepool_rates$multiplex_label <- loo_largepool_rates$multiplex
loo_largepool_rates$multiplex_label[loo_largepool_rates$multiplex=="31 Guides"] <- "32 Guides"
loo_largepool_rates$multiplex_label[loo_largepool_rates$multiplex=="7 Guides"] <- "8 Guides"
loo_largepool_rates$multiplex_label <- factor(loo_largepool_rates$multiplex_label,
                                              levels=c("No Protein", "8 Guides", "32 Guides"))
levels(loo_largepool_rates$multiplex_label) <- c("No Protein", "8 crRNAs", "32 crRNAs")

ggplot(subset(loo_largepool_rates, !((multiplex == "No Protein") | (conc == "30 fM"))), 
       aes(x=factor(conc, levels=c("RNP-only", "300 aM", "1 fM", "3 fM", "10 fM")), 
           y=Estimate)) + 
  geom_col(aes(fill=mismatch), position="dodge2") + theme_classic(base_size=10) + 
  geom_errorbar(aes(ymin = Estimate + qnorm(0.025)*Std..Error,
                    ymax = Estimate - qnorm(0.025)*Std..Error,
                    fill=mismatch),
                position="dodge") + 
  facet_grid(~factor(multiplex_label, levels=c("8 crRNAs", "32 crRNAs"))) + 
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) + 
  xlab("") + ylab("RFU/min") + labs(fill="") +
  scale_fill_manual(values=c(ucb_colors$`Lawrence`, ucb_colors$`Rose Garden`),
                    labels=c("leave one\ncrRNA out", "all crRNAs")) +
  geom_text(data=loo_largepool_mismatch, aes(x=conc, y=text_height+9, label=text), size=7) + 
  geom_errorbar(data=loo_largepool_mismatch, 
                aes(ymin=text_height+7, ymax=text_height+7), size=1)

ggsave(file=file.path(figure_dir, "suppl_figure_6.pdf"),
       plot=last_plot(),
       device="pdf", width=6.5, height=3.5, units="in")
```

gblock rates

```{r suppl_figure_x1}
gblock_rate$start <- guide_rate$start[match(gblock_rate$guide_id,
                                            guide_rate$guide_id)]
(ggplot(gblock_rate, aes(x=start, y=Estimate)) + theme_classic() + 
    geom_point() + geom_errorbar(aes(ymin=Estimate+qnorm(0.05)*Std.Error,
                                     ymax=Estimate-qnorm(0.05)*Std.Error)) + 
    xlab("") + ylab("activator-dependent rate\n(RFU/min)") + ylim(-10, 100) + 
    theme(axis.title=element_text(size=10),
          axis.text=element_text(size=10))) + 
  (ggplot(gene_bed, aes(xmin=thickStart, xmax=thickEnd, ymin=ymax-4.5, ymax=ymax)) + 
     theme_void() + geom_rect() + 
     geom_text(data=subset(gene_bed, thickEnd-thickStart > 500*nchar(geneName)),
               aes(x=(thickStart + thickEnd)/2, y=ymax-(4.5/2), label=name),
               col="white", size=2.5)) +
  (ggplot(guide_rate, aes(y=Estimate)) + theme_classic() + 
     geom_histogram(binwidth=5) + xlab("") + ylab("") + ylim(-10, 100) + 
     scale_x_continuous(breaks=c(0, 20)) +
     theme(axis.text.y=element_blank(), axis.ticks=element_blank(),
           axis.text.x=element_text(size=10))) + 
  plot_spacer() + 
  plot_layout(byrow=F, widths=c(10,1), heights=c(5,1))
# ggsave(file=file.path(figure_dir, "suppl_figure_1.pdf"),
#        plot=last_plot(),
#        device="pdf", width=6.5, height=3, units="in")
```

anti-tag complementarity

```{r suppl_figure_x2}
levels(guide_rate$antitag_label) <- c("ARRR", "CRRR", "URRR", "GRRR", "GURR", "GUUR")

ggplot(guide_rate,
       aes(x=antitag_label, y=Estimate, fill=antitag_label)) + 
  geom_violin(draw_quantiles=c(0.25, 0.75), linetype="dashed") + 
  geom_violin(fill="transparent", draw_quantiles=0.5) + 
  geom_dotplot(binaxis="y", stackdir="center", binwidth=1, fill="black") +
  theme_classic(base_size=10) + guides(fill="none") +
  scale_fill_manual(values=RColorBrewer::brewer.pal(6, "Set1")) +
  xlab("anti-tag") + ylab("activator-dependent rate\n(RFU/min)")

# ggsave(file=file.path(figure_dir, "suppl_figure_1.pdf"),
#        plot=last_plot(),
#        device="pdf", width=4, height=3, units="in")
```

interaction btwn anti-tag G and spacer structure

```{r suppl_figure_x3}
antitag_G_structure <- subset(guide_rate, 
                              antitag_pos1=="G" & crRNA_spacer_basepairs != 0 &
                                nchar(spacer)==20)
antitag_G_structure <- antitag_G_structure[order(antitag_G_structure$crRNA_spacer_basepairs),]
antitag_G_structure <- rbind(subset(guide_rate, 
                                    antitag_pos1=="G" & crRNA_spacer_basepairs==0 &
                                      nchar(spacer==20))[1,],
                             antitag_G_structure)
antitag_G_structure$Estimate[1] <- mean(subset(guide_rate, 
                                               antitag_pos1=="G" & crRNA_spacer_basepairs==0 &
                                                 nchar(spacer==20))$Estimate)
antitag_G_structure$spacer_structure <- sapply(as.character(antitag_G_structure$structure),
                                               function(x) {
                                                 substr(x, nchar(x)-20+1, nchar(x))
                                               })

(ggplot(subset(guide_rate, 
               crRNA_spacer_basepairs %in% c(0, 4, 10, 16) & 
                 antitag_pos1=="G" &
                 nchar(spacer)==20),
        aes(x=as.numeric(as.character(crRNA_spacer_basepairs)), 
            y=Estimate)) + 
    geom_violin(aes(fill=crRNA_spacer_basepairs), alpha=0.25, 
                draw_quantiles=c(0.25, 0.75), linetype="dashed") + 
    geom_violin(aes(fill=crRNA_spacer_basepairs), alpha=0.25, draw_quantiles=0.5) + 
    geom_dotplot(aes(fill=crRNA_spacer_basepairs), 
                 binaxis="y", stackdir="center", binwidth=1) + 
    geom_smooth(method=lm, formula=y~x) + 
    theme_classic() + guides(fill="none") + 
    theme(axis.text=element_text(size=10), axis.title=element_text(size=10)) +
    scale_x_continuous(breaks=c(0, 4, 10, 16)) + 
    xlab("# basepaired positions in spacer") + 
    ylab("activator-dependent rate\n(RFU/min)")) /
  (ggplot(antitag_G_structure, 
          aes(x=spacer_structure, y=Estimate, fill=crRNA_spacer_basepairs, group=NCR.id)) + 
     geom_col(position=position_dodge2(preserve="single")) + theme_classic() + 
     theme(axis.text.x=element_text(angle=90, vjust=0.5)) + 
     xlab("") + ylab("activator-dependent rate\n(RFU/min)"))
```

```{r save_image}
write.csv(guide_features, file=file.path(project_dir, "guide_features.csv"), row.names=F)
write.csv(guide_rate, file=file.path(project_dir, "guide_rate.csv"), row.names=F)
save.image(file=file.path(project_dir, ".RData"))
```